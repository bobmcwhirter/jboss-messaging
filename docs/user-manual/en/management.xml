<?xml version="1.0" encoding="UTF-8"?>
<chapter id="management">
   <title>Management</title>
   <para>JBoss Messaging has an extensive management API that allows a user to modify a server
      configuration, create new resources (e.g. JMS queues and topics), inspect these resources
      (e.g. how many messages are currently held in a queue) and interact with it (e.g. to remove
      messages from a queue). All the operations allows a client to <emphasis>manage</emphasis>
      JBoss Messaging. It also allows clients to subscribe to management notifications.</para>
   <para>There are 3 ways to manage JBoss Messaging:</para>
   <itemizedlist>
      <listitem>
         <para>Using JMX -- JMX is the standard way to manage Java applications</para>
      </listitem>
      <listitem>
         <para>Using the core API -- management operations are sent to JBoss Messaging server using
               <emphasis>core messages</emphasis></para>
      </listitem>
      <listitem>
         <para>Using the JMS API -- management operations are sent to JBoss Messaging server using
               <emphasis>JMS messages</emphasis></para>
      </listitem>
   </itemizedlist>
   <para>Although there are 3 different ways to manage JBoss Messaging each API supports the same
      functionality. If it is possible to manage a resource using JMX it is also possible to achieve
      the same result using Core messages or JMS messages.</para>
   <para>This choice depends on your requirements, your application settings and your environment to
      decide which way suits you best.</para>
   <section>
      <title>The Management API</title>
      <para>Regardless of the way you <emphasis>invoke</emphasis> management operations, the
         management API is the same.</para>
      <para>For each <emphasis>managed resource</emphasis>, there exists a Java interface describing
         what can be invoked for this type of resource.</para>
      <para>JBoss Messaging exposes its managed resources in 2 packages:</para>
      <itemizedlist>
         <listitem>
            <para><emphasis>Core</emphasis> resources are located in the <literal
                  >org.jboss.messaging.core.management</literal> package</para>
         </listitem>
         <listitem>
            <para><emphasis>JMS</emphasis> resources are located in the <literal
                  >org.jboss.messaging.jms.server.management</literal> package</para>
         </listitem>
      </itemizedlist>
      <para>The way to invoke a <emphasis>management operations</emphasis> depends whether JMX, core
         messages, or JMS messages are used.</para>
         
      <note>
         <para>A few management operations requires a <literal>filter</literal> parameter to chose which
         messages are involved by the operation. Passing
         <literal>null</literal> or an empty string means that the management operation will be performed
         on <emphasis>all messages</emphasis>.</para>
      </note>
         
      <section>
         <title>Core Management API</title>
         <para>JBoss Messaging defines a core management API to manage core resources. For full
            details of the API please consult the javadoc. In summary:</para>
         <section>
            <title>Core Server Management</title>
            <itemizedlist>
               <listitem>
                  <para>Creating, deploying and destroying queues</para>
                  <para>Core queues can be created or destroyed using the management operations
                        <literal>createQueue()</literal> or <literal>deployQueue()</literal> or
                        <literal>destroyQueue()</literal>)on the <literal
                        >MessagingServerControl</literal> (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=Server</literal> or the resource name
                        <literal>core.server</literal>)</para>
                  <para><literal>createQueue</literal> will fail if the queue already exists while
                        <literal>deployQueue</literal> will do nothing.</para>
               </listitem>
               <listitem>
                  <para>Listing and closing remote connections</para>
                  <para>Client's remote addresses can be retrieved using <literal
                        >listRemoteAddresses()</literal>. It is also possible to close the
                     connections associated with a remote address using the <literal
                        >closeConnectionsForAddress()</literal> method.</para>
                  <para>Alternatively, connection IDs can be listed using <literal
                        >listConnectionIDs()</literal> and all the sessions for a given connection
                     ID can be listed using <literal>listSessions()</literal>.</para>
               </listitem>
               <listitem>
                  <para>Transaction heuristic operations</para>
                  <para>In case of a server crash, when the server restarts, it it possible that
                     some transaction requires manual intervention. The <literal
                        >listPreparedTransactions()</literal> method lists the transactions which
                     are in the prepared states (the transactions are represented as opaque Base64
                     Strings.) To commit or rollback a given prepared transaction, the <literal
                        >commitPreparedTransaction</literal>() or <literal
                        >rollbackPreparedTransaction()</literal> method can be used to resolve
                     heuristic transactions.</para>
               </listitem>
               <listitem>
                  <para>Enabling and resetting Message counters</para>
                  <para>Message counters can be enabled or disabled using the <literal
                        >enableMessageCounters()</literal> or <literal
                        >disableMessageCounters()</literal> method. To reset message counters, it is
                     possible to invoke <literal>resetAllMessageCounters()</literal> and <literal
                        >resetAllMessageCounterHistories()</literal> methods.</para>
               </listitem>
               <listitem>
                  <para>Retrieving the server configuration and attributes</para>
                  <para>The <literal>MessagingServerControl</literal> exposes JBoss Messaging
                     server configuration through all its attributes (e.g. <literal
                        >getVersion()</literal> method to retrieve the server's version,
                     etc.)</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>Core Address Management</title>
            <para>Core addresses can be managed using the <literal>AddressControl</literal>
               class (with the ObjectName <literal
                  >org.jboss.messaging:module=Core,type=Address,name="&lt;the address
                  name&gt;"</literal> or the resource name <literal>core.address.&lt;the address
                  name&gt;</literal>). </para>
            <itemizedlist>
               <listitem>
                  <para>Modifying roles and permissions for an address</para>
                  <para>You can add or remove roles associated to a queue using the <literal
                        >addRole()</literal> or. <literal>removeRole()</literal> methods. You can
                     list all the roles associated to the queue with the <literal
                        >getRoles()</literal> method</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>Core Queue Management</title>
            <para>The bulk of the core management API deals with core queues. The <literal
                  >QueueControl</literal> class defines the Core queue management operations
               (with the ObjectName <literal
                  >org.jboss.messaging:module=Core,type=Queue,address="&lt;the bound
                  address&gt;",name="&lt;the queue name&gt;"</literal> or the resource name <literal
                  >core.queue.&lt;the queue name&gt;</literal>).</para>
            <para>Most of the management operations on queues take either a single message ID (e.g.
               to remove a single message) or a filter (e.g. to expire all messages with a given
               property.)</para>
            <itemizedlist>
               <listitem>
                  <para>Expiring, sending to a dead letter address and moving messages</para>
                  <para>Messages can be expired from a queue by using the <literal
                        >expireMessages()</literal> method. If an expiry address is defined,
                     messages will be be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <literal>setExpiryAddress()</literal>
                     method.</para>
                  <para>Messages can also be sent to a dead letter address with the <literal
                        >sendMessagesToDeadLetterAddress()</literal> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <literal
                        >setDeadLetterAddress()</literal> method.</para>
                  <para>Messages can also be moved from a queue to another queue by using the
                        <literal>moveMessages()</literal> method.</para>
               </listitem>
               <listitem>
                  <para>Listing and removing messages</para>
                  <para>Messages can be listed from a queue by using the <literal
                        >listMessages()</literal> method which returns an array of <literal
                        >Map</literal>, one <literal>Map</literal> for each message.</para>
                  <para>Messages can also be removed from the queue by using the <literal
                        >removeMessages()</literal> method which returns a <literal
                        >boolean</literal> for the single message ID variant or the number of
                     removed messages for the filter variant.</para>
               </listitem>
               <listitem>
                  <para>Counting messages</para>
                  <para>The number of messages in a queue is returned by the <literal
                        >getMessageCount()</literal> method. Alternatively, the <literal
                        >countMessages()</literal> will return the number of messages in the queue
                     which <emphasis>match a given filter</emphasis></para>
               </listitem>
               <listitem>
                  <para>Changing message priority</para>
                  <para>The message priority can be changed by using the <literal
                        >changeMessagesPriority()</literal> method which returns a <literal
                        >boolean</literal> for the single message ID variant or the number of
                     updated messages for the filter variant.</para>
               </listitem>
               <listitem>
                  <para>Message counters</para>
                  <para>Message counters can be listed for a queue with the <literal
                        >listMessageCounter()</literal> and <literal
                        >listMessageCounterHistory()</literal> methods (see <xref
                        linkend="management.message-counters"/>). The message counters can also be
                     reset for a single queue using the <literal>resetMessageCounter()</literal>
                     method.</para>
               </listitem>
               <listitem>
                  <para>Retrieving the queue attributes</para>
                  <para>The <literal>QueueControl</literal> exposes Core queue settings through
                     its attributes (e.g. <literal>getFilter()</literal> to retrieve the queue's
                     filter if it was created with one, <literal>isDurable()</literal> to know
                     wether the queue is durable or not, etc.)</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>Other Core Resources Management</title>
            <para>JBoss Messaging allows to start and stop its remote resources (acceptors, diverts,
               bridges, etc.) so that a server can be taken off line for a given period of time
               without stopping it completely (e.g. if other management operations must be performed
               such as resolving heuristic transactions). These resources are:</para>
            <itemizedlist>
               <listitem>
                  <para>Acceptors</para>
                  <para>They can be started or stopped using the <literal>start()</literal> or.
                        <literal>stop()</literal> method on the <literal
                        >AcceptorControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=Acceptor,name="&lt;the acceptor
                        name&gt;"</literal> or the resource name <literal>core.acceptor.&lt;the
                        address name&gt;</literal>). The acceptors parameters can be retrieved using
                     the <literal>AcceptorControl</literal> attributes (see <xref
                        linkend="configuring-transports.acceptors"/>)</para>
               </listitem>
               <listitem>
                  <para>Diverts</para>
                  <para>They can be started or stopped using the <literal>start()</literal> or
                        <literal>stop()</literal> method on the <literal
                        >DivertControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=Divert,name=&lt;the divert
                        name&gt;</literal> or the resource name <literal>core.divert.&lt;the divert
                        name&gt;</literal>). Diverts parameters can be retrieved using the <literal
                        >DivertControl</literal> attributes (see <xref linkend="diverts"
                     />)</para>
               </listitem>
               <listitem>
                  <para>Bridges</para>
                  <para>They can be started or stopped using the <literal>start()</literal> (resp.
                        <literal>stop()</literal>) method on the <literal
                        >BridgeControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=Bridge,name="&lt;the bridge
                        name&gt;"</literal> or the resource name <literal>core.bridge.&lt;the bridge
                        name&gt;</literal>). Bridges parameters can be retrieved using the <literal
                        >BridgeControl</literal> attributes (see <xref linkend="core-bridges"
                     />)</para>
               </listitem>
               <listitem>
                  <para>Broadcast groups</para>
                  <para>They can be started or stopped using the <literal>start()</literal> or
                        <literal>stop()</literal> method on the <literal
                        >BroadcastGroupControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=BroadcastGroup,name="&lt;the broadcast
                        group name&gt;"</literal> or the resource name <literal
                        >core.broadcastgroup.&lt;the broadcast group name&gt;</literal>). Broadcast
                     groups parameters can be retrieved using the <literal
                        >BroadcastGroupControl</literal> attributes (see <xref
                        linkend="clusters.broadcast-groups"/>)</para>
               </listitem>
               <listitem>
                  <para>Discovery groups</para>
                  <para>They can be started or stopped using the <literal>start()</literal> or
                        <literal>stop()</literal> method on the <literal
                        >DiscoveryGroupControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=DiscoveryGroup,name="&lt;the discovery
                        group name&gt;"</literal> or the resource name <literal
                        >core.discovery.&lt;the discovery group name&gt;</literal>). Discovery
                     groups parameters can be retrieved using the <literal
                        >DiscoveryGroupControl</literal> attributes (see <xref
                        linkend="clusters.discovery-groups"/>)</para>
               </listitem>
               <listitem>
                  <para>Cluster connections</para>
                  <para>They can be started or stopped using the <literal>start()</literal> or
                        <literal>stop()</literal> method on the <literal
                        >ClusterConnectionControl</literal> class (with the ObjectName <literal
                        >org.jboss.messaging:module=Core,type=ClusterConnection,name="&lt;the
                        cluster connection name&gt;"</literal> or the resource name <literal
                        >core.clusterconnection.&lt;the cluster connection name&gt;</literal>).
                     Cluster connections parameters can be retrieved using the <literal
                        >ClusterConnectionControl</literal> attributes (see <xref
                        linkend="clusters.cluster-connections"/>)</para>
               </listitem>
            </itemizedlist>
         </section>
      </section>
      <section>
         <title>JMS Management API</title>
         <para>JBoss Messaging defines a JMS Management API to manage JMS <emphasis>administrated
               objects</emphasis> (i.e. JMS queues, topics and connection factories).</para>
         <section>
            <title>JMS Server Management</title>
            <para>JMS Resources (connection factories and destinations) can be created using the
                  <literal>JMSServerControl</literal> class (with the ObjectName <literal
                  >org.jboss.messaging:module=JMS,type=Server</literal> or the resource name
                  <literal>jms.server</literal>).</para>
            <itemizedlist>
               <listitem>
                  <para>Creating/destroying connection factories</para>
                  <para>JMS connection factories can be created or destroyed using the <literal
                        >createConnectionFactory()</literal> methods or <literal
                        >destroyConnectionFactory()</literal> methods. These connection factories
                     are bound to JNDI so that JMS clients can look them up.
                     If a graphical console is used to create the connection factories, the 
                     transport parameters are specified in the text fied input as a comma-separated 
                     list of key=value
                     (e.g. <literal>key1=10, key2="value", key3=false</literal>). If there are multiple
                     transports defined, you need to enclose the key/value pairs between curly braces.
                     For example <literal>{key=10}, {key=20}</literal>. In that case, the first 
                     <literal>key</literal> will be associated to the first transport configuration and the
                     second <literal>key</literal> will be associated to the second transport configuration.</para>
               </listitem>
               <listitem>
                  <para>Creating/destroying queues</para>
                  <para>JMS queues can be created or destroyed using the <literal
                        >createQueue()</literal> methods or <literal>destroyQueue()</literal>
                     methods. These queues are bound to JNDI so that JMS clients can look them
                     up</para>
               </listitem>
               <listitem>
                  <para>Creating/destroying topics</para>
                  <para>JMS topics can be created or destroyed using the <literal
                        >createTopic()</literal> or <literal>destroyTopic()</literal> methods. These
                     topics are bound to JNDI so that JMS clients can look them up</para>
               </listitem>
               <listitem>
                  <para>Listing and closing remote connections</para>
                  <para>JMS Clients remote addresses can be retrieved using <literal
                        >listRemoteAddresses()</literal>. It is also possible to close the
                     connections associated with a remote address using the <literal
                        >closeConnectionsForAddress()</literal> method.</para>
                  <para>Alternatively, connection IDs can be listed using <literal
                        >listConnectionIDs()</literal> and all the sessions for a given connection
                     ID can be listed using <literal>listSessions()</literal>.</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS ConnectionFactory Management</title>
            <para>JMS Connection Factories can be managed using the <literal
                  >ConnectionFactoryControl</literal> class (with the ObjectName <literal
                  >org.jboss.messaging:module=JMS,type=ConnectionFactory,name="&lt;the connection
                  factory name&gt;"</literal> or the resource name <literal
                  >jms.connectionfactory.&lt;the connection factory name&gt;</literal>).</para>
            <itemizedlist>
               <listitem>
                  <para>Retrieving connection factory attributes</para>
                  <para>The <literal>ConnectionFactoryControl</literal> exposes JMS
                     ConnectionFactory configuration through its attributes (e.g. <literal
                        >getConsumerWindowSize()</literal> to retrieve the consumer window size for
                     flow control, <literal>isBlockOnNonPersistentSend()</literal> to know wether
                     the producers created from the connection factory will block or not when
                     sending non-persistent messages, etc.)</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS Queue Management</title>
            <para>JMS queues can be managed using the <literal>JMSQueueControl</literal> class
               (with the ObjectName <literal>org.jboss.messaging:module=JMS,type=Queue,name="&lt;the
                  queue name&gt;"</literal> or the resource name <literal>jms.queue.&lt;the queue
                  name&gt;</literal>). </para>
            <para><emphasis>The management operations on a JMS queue are very similar to the
                  operations on a core queue. </emphasis></para>
            <itemizedlist>
               <listitem>
                  <para>Expiring, sending to a dead letter address and moving messages</para>
                  <para>Messages can be expired from a queue by using the <literal
                        >expireMessages()</literal> method. If an expiry address is defined,
                     messages will be be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <literal>setExpiryAddress()</literal>
                     method.</para>
                  <para>Messages can also be sent to a dead letter address with the <literal
                        >sendMessagesToDeadLetterAddress()</literal> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <literal
                        >setDeadLetterAddress()</literal> method.</para>
                  <para>Messages can also be moved from a queue to another queue by using the
                        <literal>moveMessages()</literal> method.</para>
               </listitem>
               <listitem>
                  <para>Listing and removing messages</para>
                  <para>Messages can be listed from a queue by using the <literal
                        >listMessages()</literal> method which returns an array of <literal
                        >Map</literal>, one <literal>Map</literal> for each message.</para>
                  <para>Messages can also be removed from the queue by using the <literal
                        >removeMessages()</literal> method which returns a <literal
                        >boolean</literal> for the single message ID variant or the number of
                     removed messages for the filter variant.</para>
               </listitem>
               <listitem>
                  <para>Counting messages</para>
                  <para>The number of messages in a queue is returned by the <literal
                        >getMessageCount()</literal> method. Alternatively, the <literal
                        >countMessages()</literal> will return the number of messages in the queue
                     which <emphasis>match a given filter</emphasis></para>
               </listitem>
               <listitem>
                  <para>Changing message priority</para>
                  <para>The message priority can be changed by using the <literal
                        >changeMessagesPriority()</literal> method which returns a <literal
                        >boolean</literal> for the single message ID variant or the number of
                     updated messages for the filter variant.</para>
               </listitem>
               <listitem>
                  <para>Message counters</para>
                  <para>Message counters can be listed for a queue with the <literal
                        >listMessageCounter()</literal> and <literal
                        >listMessageCounterHistory()</literal> methods (see <xref
                        linkend="management.message-counters"/>)</para>
               </listitem>
               <listitem>
                  <para>Retrieving the queue attributes</para>
                  <para>The <literal>JMSQueueControl</literal> exposes JMS queue settings
                     through its attributes (e.g. <literal>isTemporary()</literal> to know wether
                     the queue is temporary or not, <literal>isDurable()</literal> to know wether
                     the queue is durable or not, etc.)</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS Topic Management</title>
            <para>JMS Topics can be managed using the <literal>TopicControl</literal> class
               (with the ObjectName <literal>org.jboss.messaging:module=JMS,type=Topic,name="&lt;the
                  topic name&gt;"</literal> or the resource name <literal>jms.topic.&lt;the topic
                  name&gt;</literal>).</para>
            <itemizedlist>
               <listitem>
                  <para>Listing subscriptions and messages</para>
                  <para>JMS topics subscriptions can be listed using the <literal
                        >listAllSubscriptions()</literal>, <literal
                        >listDurableSubscriptions()</literal>, <literal
                        >listNonDurableSubscriptions()</literal> methods. These methods return
                     arrays of <literal>Object</literal> representing the subscriptions information
                     (subscription name, client ID, durability, message count, etc.). It is also
                     possible to list the JMS messages for a given subscription with the <literal
                        >listMessagesForSubscription()</literal> method.</para>
               </listitem>
               <listitem>
                  <para>Dropping subscriptions</para>
                  <para>Durable subscriptions can be dropped from the topic using the <literal
                        >dropDurableSubscription()</literal> method.</para>
               </listitem>
               <listitem>
                  <para>Counting subscriptions messages</para>
                  <para>The <literal>countMessagesForSubscription()</literal> method can be used to
                     know the number of messages held for a given subscription (with an optional
                     message selector to know the number of messages matching the selector)</para>
               </listitem>
            </itemizedlist>
         </section>
      </section>
   </section>
   <section id="management.jmx">
      <title>Using Management Via JMX</title>
      <para>JBoss Messaging can be managed using <ulink
            url="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/"
         >JMX</ulink>. </para>
      <para>The management API is exposed by JBoss Messaging using MBeans interfaces. JBoss
         Messaging registers its resources with the domain <literal
         >org.jboss.messaging</literal>.</para>
      <para>For example, the <literal>ObjectName</literal> to manage a JMS Queue <literal
            >exampleQueue</literal> is:</para>
      <programlisting>
   org.jboss.messaging:module=JMS,type=Queue,name="exampleQueue"   
      </programlisting>
      <para>and the MBean is:</para>
      <programlisting>
   org.jboss.messaging.jms.server.management.JMSQueueControl   
      </programlisting>
      <para>The MBean's <literal>ObjectName</literal> are built using the helper class <literal
            >org.jboss.messaging.core.management.ObjectNames</literal>. You can also use <literal
            >jconsole</literal> to find the <literal>ObjectName</literal> of the MBeans you want to
         manage. </para>
      <para>Managing JBoss Messaging using JMX is identical to management of any Java Applications
         using JMX. It can be done by reflection or by creating proxies of the MBeans.</para>
      <section id="management.jmx.configuration">
         <title>Configuring JMX</title>
         <para>By default, JMX is enabled to manage JBoss Messaging. It can be disabled by setting
               <literal>jmx-management-enabled</literal> to <literal>false</literal> in <literal
               >jbm-configuration.xml</literal>:</para>
         <programlisting>
&lt;!-- false to disable JMX management for JBoss Messaging --&gt;
&lt;jmx-management-enabled&gt;false&lt;/jmx-management-enabled&gt;            
         </programlisting>
         <para>If JMX is enabled, JBoss Messaging can be managed locally using <literal
               >jconsole</literal>. Remote connections to JMX are not enabled by default for
            security reasons. Please refer to <ulink
               url="http://java.sun.com/j2se/1.5.0/docs/guide/management/agent.html#remote">Java
               Management guide</ulink> to configure the server for remote management (system
            properties must be set in <literal>run.sh</literal> or <literal>run.bat</literal>
            scripts).</para>
            
         <section>
            <title>MBeanServer configuration</title>
            
            <para>When JBoss Messaging is run in standalone, it uses the Java Virtual Machine's <literal>Platform
               MBeanServer</literal> to register its MBeans. This is configured in JBoss
            Microcontainer Beans file (see <xref linkend="server.microcontainer.configuration"
            />):</para>
            <programlisting>&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                         factoryMethod="getPlatformMBeanServer" /&gt;
&lt;/bean&gt;            
            </programlisting>
         
            <para>When it is integrated in JBoss AS 5, it uses the Application Server's own
               MBean Server so that it can be managed using AS 5's jmx-console:</para>
            <programlisting>&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                         factoryMethod="locateJBoss" /&gt;
&lt;/bean&gt;            
            </programlisting>
         </section>         
      </section>
      
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.jmx" /> for an example which 
            shows how to use a remote connection to JMX and MBean proxies to
            manage JBoss Messaging.</para>
      </section>
   </section>
   <section>
      <title>Using Management Via Core API</title>
      <para>The core management API in JBoss Messaging is called by sending Core messages to a
         special address, the <emphasis>management address</emphasis>.</para>
      <para><emphasis>Management messages</emphasis> are regular Core messages with well-known
         properties that the server needs to understand to interact with the management API:</para>
      <itemizedlist>
         <listitem>
            <para>The name of the managed resource</para>
         </listitem>
         <listitem>
            <para>The name of the management operation</para>
         </listitem>
         <listitem>
            <para>The parameters of the management operation</para>
         </listitem>
      </itemizedlist>
      <para>When such a management message is sent to the management address, JBoss Messaging server
         will handle it, extract the information, invoke the operation on the managed resources and
         send a <emphasis>management reply</emphasis> to the management message's reply-to address
         (specified by <literal>ClientMessageImpl.REPLYTO_HEADER_NAME</literal>). </para>
      <para>A <literal>ClientConsumer</literal> can be used to consume the management reply and
         retrieve the result of the operation (if any) stored in the reply's body. For portability,
         results are returned as a <ulink url="http://json.org">JSON</ulink> String rather than Java
         Serialization (the <literal
            >org.jboss.messaging.core.client.management.impl.ManagementHelper</literal> can be used
         to convert the JSON string to Java objects).</para>
      <para>These steps can be simplified to make it easier to invoke management operations using
         Core messages:</para>
      <orderedlist>
         <listitem>
            <para>Create a <literal>ClientRequestor</literal> to send messages to the management
               address and receive replies</para>
         </listitem>
         <listitem>
            <para>Create a <literal>ClientMessage</literal></para>
         </listitem>
         <listitem>
            <para>Use the helper class <literal
                  >org.jboss.messaging.core.client.management.impl.ManagementHelper</literal> to
               fill the message with the management properties</para>
         </listitem>
         <listitem>
            <para>Send the message using the <literal>ClientRequestor</literal></para>
         </listitem>
         <listitem>
            <para>Use the helper class <literal
                  >org.jboss.messaging.core.client.management.impl.ManagementHelper</literal> to
               retrieve the operation result from the management reply</para>
         </listitem>
      </orderedlist>
      <para>For example, to find out the number of messages in the core queue <literal
            >exampleQueue</literal>:</para>
      <programlisting>
   ClientSession session = ...
   ClientRequestor requestor = new ClientRequestor(session, "jbm.management");
   ClientMessage message = session.createClientMessage(false);
   ManagementHelper.putAttribute(message, "core.queue.exampleQueue", "messageCount");
   ClientMessage reply = requestor.request(m);
   int count = (Integer) ManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </programlisting>
      <para>Management operation name and parameters must conform to the Java interfaces defined in
         the <literal>management</literal> packages.</para>
      <para>Names of the resources are built using the helper class <literal
            >org.jboss.messaging.core.management.ResourceNames</literal> and are straightforward
            (<literal>core.queue.exampleQueue</literal> for the Core Queue <literal
            >exampleQueue</literal>, <literal>jms.topic.exampleTopic</literal> for the JMS Topic
            <literal>exampleTopic</literal>, etc.).</para>
      <section id="management.core.configuration">
         <title>Configuring Core Management</title>
         <para>The management address to send management messages is configured in <literal
               >jbm-configuration.xml</literal>:</para>
         <programlisting>
   &lt;management-address&gt;jbm.management&lt;/management-address&gt;
         </programlisting>
         <para>By default, the address is <literal>jbm.management</literal>.</para>
         <para>The management address requires a <emphasis>special</emphasis> user permission
               <literal>manage</literal> to be able to receive and handle management messages. This
            is also configured in jbm-configuration.xml:</para>
         <programlisting>
   &lt;!-- users with the admin role will be allowed to manage --&gt; 
   &lt;!-- JBoss Messaging using management messages        --&gt;
   &lt;security-setting match="jbm.management"&gt;
      &lt;permission type="manage" roles="admin" /&gt;
   &lt;/security-setting&gt;
         </programlisting>
      </section>
   </section>
   <section id="management.jms">
      <title>Using Management Via JMS</title>
      <para>Using JMS messages to manage JBoss Messaging is very similar to using core API.</para>
      <para>An important difference is that JMS requires a JMS queue to send the messages to
         (instead of an address for the core API).</para>
      <para>The <emphasis>management queue</emphasis> is a special queue and needs to be
         instantiated directly by the client:</para>
      <programlisting>
   Queue managementQueue = new JBossQueue("jbm.management", "jbm.management");   
      </programlisting>
      <para>All the other steps are the same than for the Core API but they use JMS API
         instead:</para>
      <orderedlist>
         <listitem>
            <para>create a <literal>QueueRequestor</literal> to send messages to the management
               address and receive replies</para>
         </listitem>
         <listitem>
            <para>create a <literal>Message</literal></para>
         </listitem>
         <listitem>
            <para>use the helper class <literal
                  >org.jboss.messaging.jms.server.management.impl.JMSManagementHelper</literal> to
               fill the message with the management properties</para>
         </listitem>
         <listitem>
            <para>send the message using the <literal>QueueRequestor</literal></para>
         </listitem>
         <listitem>
            <para>use the helper class <literal
                  >org.jboss.messaging.jms.server.management.impl.JMSManagementHelper</literal> to
               retrieve the operation result from the management reply</para>
         </listitem>
      </orderedlist>
      <para>For example, to know the number of messages in the JMS queue <literal
            >exampleQueue</literal>:</para>
      <programlisting>
   Queue managementQueue = new JBossQueue("jbm.management", "jbm.management");   
   
   QueueSession session = ...      
   QueueRequestor requestor = new QueueRequestor(session, managementQueue);
   connection.start();
   Message message = session.createMessage();
   JMSManagementHelper.putAttribute(message, "jms.queue.exampleQueue", "managementQueueessageCount");
   Message reply = requestor.request(message);
   int count = (Integer)JMSManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </programlisting>
      <section>
         <title>Configuring JMS Management</title>
         <para>Whether JMS or the core API is used for management, the configuration steps are the
            same (see <xref linkend="management.core.configuration"/>).</para>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.management" /> for an example which shows how to use 
            JMS messages to manage JBoss Messaging server.</para>
      </section>
   </section>
   <section id="management.replication">
      <title>Management Cluster Credentials</title>
      <para>JBoss Messaging allows <emphasis>replication</emphasis> of a live server to a backup
         server. This impacts management as resources created on the live server (e.g. a core
         address) must also be created on the backup server. Otherwise, when failover occurs, the
         backup server will not be able to handle messages sent to this address since its resources
         will have been created on the live server only and not on the backup.</para>
      <para>JBoss Messaging <emphasis>replicates management operations</emphasis> regardless of the
         management API used (JMX, Core messages, JMS messages). Any management operation invoked on
         a live server will also be invoked on its backup server to ensure a proper replication of
         resources and state. For example, you only need to manage the live server: if a queue is
         created on the live server, JBoss Messaging will ensure that the same resource will also be
         created on the backup server.</para>
      <para>If core or JMS messages are used to invoke management operations, replication is handled
         automatically by JBoss Messaging.</para>
      <para>To allow this management replication with JMX, JBoss Messaging defines 
            <emphasis>management cluster credentials</emphasis>: this special user/password <emphasis>must
            be shared by all nodes</emphasis>. To configure it, change the value in <literal
            >jbm-configuration.xml</literal>:</para>
      <programlisting>
   &lt;management-cluster-user&gt;JBM.MANAGEMENT.ADMIN.USER&lt;/management-cluster-user&gt;
   &lt;management-cluster-password&gt;CHANGE ME!!&lt;/management-cluster-password&gt;
      </programlisting>
      <para>It is strongly suggested to
         change these values from their default. If they are not changed from the default, JBoss Messaging will
         detect this and pester you with a warning on every start-up.</para>
      <para>JBoss Messaging internally uses Core messages to replicate management operations between
         the live and backup server when JMX is used. By default, there is a timeout of 5s (5000ms)
         to send a management request from the live server to the backup server and wait for a
         reply. If a reply is not received before the timeout is hit, JBoss Messaging considers the
         replication has failed. This timeout can be configured in <literal
            >jbm-configuration.xml</literal>:</para>
      <programlisting>
         &lt;management-request-timeout&gt;5000&lt;/management-request-timeout&gt;
      </programlisting>
   </section>
   <section id="management.notifications">
      <title>Management Notifications</title>
      <para>JBoss Messaging emits <emphasis>notifications</emphasis> to inform listeners of
         potentially interesting events (creation of new resources, security violation,
         etc.).</para>
      <para>These notifications can be received by 3 different ways:</para>
      <itemizedlist>
         <listitem>
            <para>JMX notifications</para>
         </listitem>
         <listitem>
            <para>Core messages</para>
         </listitem>
         <listitem>
            <para>JMS messages</para>
         </listitem>
      </itemizedlist>
      <section>
         <title>JMX Notifications</title>
         <para>If JMX is enabled (see <xref linkend="management.jmx.configuration"/>), JMX
            notifications can be received by subscribing to 2 MBeans:</para>
         <itemizedlist>
            <listitem>
               <para><literal>org.jboss.messaging:module=Core,type=Server</literal> for
                  notifications on <emphasis>Core</emphasis> resources</para>
            </listitem>
            <listitem>
               <para><literal>org.jboss.messaging:module=JMS,type=Server</literal> for notifications
                  on <emphasis>JMS</emphasis> resources</para>
            </listitem>
         </itemizedlist>
      </section>
      <section>
         <title>Core Messages Notifications</title>
         <para>JBoss Messaging defines a special <emphasis>management notification
               address</emphasis>. Core queues can be bound to this address so that clients will
            receive management notifications as Core messages</para>
         <para>A Core client which wants to receive management notifications must create a core
            queue bound to the management notification address. It can then receive the
            notifications from its queue.</para>
         <para>Notifications messages are regular core messages with additional properties
            corresponding to the notification (its type, when it occurred, the resources which were
            concerned, etc.).</para>
         <para>Since notifications are regular core messages, it is possible to use message
            selectors to filter out notifications and receives only a subset of all the
            notifications emitted by the server.</para>
         <section id="management.notifications.core.configuration">
            <title>Configuring The Core Management Notification Address</title>
            <para>the management notification address to receive management notifications is
               configured in <literal>jbm-configuration.xml</literal>:</para>
            <programlisting>
               &lt;management-notification-address&gt;jbm.notifications&lt;/management-notification-address&gt;
            </programlisting>
            <para>By default, the address is <literal>jbm.notifications</literal>.</para>
         </section>
      </section>
      <section>
         <title>JMS Messages Notifications</title>
         <para>JBoss Messaging's notifications can also be received using JMS messages.</para>
         <para>It is similar to receiving notifications using Core API but an important difference
            is that JMS requires a JMS Destination to receive the messages (preferably a
            Topic):</para>
         <programlisting>
   Topic notificationsTopic = new JBossTopic("jbm.notifications", "jbm.notifications");
         </programlisting>
         <para>Once the notification topic is created, you can receive messages from it or set a
               <literal>MessageListener</literal>:</para>
         <programlisting>
   Topic notificationsTopic = new JBossTopic("jbm.notifications", "jbm.notifications");

   Session session = ...
   MessageConsumer notificationConsumer = session.createConsumer(notificationsTopic);
      notificationConsumer.setMessageListener(new MessageListener()
      {
         public void onMessage(Message notif)
         {
            System.out.println("------------------------");
            System.out.println("Received notification:");
            try
            {
               Enumeration propertyNames = notif.getPropertyNames();
               while (propertyNames.hasMoreElements())
               {
                  String propertyName = (String)propertyNames.nextElement();
                  System.out.format("  %s: %s\n", propertyName, notif.getObjectProperty(propertyName));
               }
            }
            catch (JMSException e)
            {
            }
            System.out.println("------------------------");
         }            
      });            
         </programlisting>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.management-notifications" /> for an example which
            shows how to use a
            JMS <literal>MessageListener</literal> to receive management notifications from JBoss
            Messaging server.</para>
      </section>
   </section>
   <section id="management.message-counters">
      <title>Message Counters</title>
      <para>Message counters can be used to obtain information on queues <emphasis>over
            time</emphasis> as JBoss Messaging keeps a history on queue metrics.</para>
      <para>They can be used to show <emphasis>trends</emphasis> on queues. For example, using the
         management API, it would be possible to query the number of messages in a queue at regular
         interval. However, this would not be enough to know if the queue is used: the number of
         messages can remain constant because nobody is sending or receiving messages from the queue
         or because there are as many messages sent to the queue than messages consumed from it. The
         number of messages in the queue remains the same in both cases but its use is widely
         different.</para>
      <para>Message counters gives additional information about the queues:</para>
      <itemizedlist>
         <listitem>
            <para><literal>count</literal></para>
            <para>The <emphasis>total</emphasis> number of messages added to the queue since the
               server was started</para>
         </listitem>
         <listitem>
            <para><literal>countDelta</literal></para>
            <para>the number of messages added to the queue <emphasis>since the last message counter
                  update</emphasis></para>
         </listitem>
         <listitem>
            <para><literal>depth</literal></para>
            <para>The <emphasis>current</emphasis> number of messages in the queue</para>
         </listitem>
         <listitem>
            <para><literal>depthDelta</literal></para>
            <para>The <emphasis>overall</emphasis> number of messages added/removed from the queue
                  <emphasis>since the last message counter update</emphasis>. For example, if
                  <literal>depthDelta</literal> is equal to <literal>-10</literal> this means that
               overall 10 messages have been removed from the queue (e.g. 2 messages were added and
               12 were removed)</para>
         </listitem>
         <listitem>
            <para><literal>lastAddTimestamp</literal></para>
            <para>The timestamp of the last time a message was added to the queue</para>
         </listitem>
         <listitem>
            <para><literal>udpateTimestamp</literal></para>
            <para>The timestamp of the last message counter update</para>
         </listitem>
      </itemizedlist>
      <section id="configuring.message.counters">
         <title>Configuring Message Counters</title>
         <para>By default, message counters are disabled as it might have a small negative effect on
            memory (the metrics are kept in memory) and CPU (the queues are sampled at regular
            interval).</para>
         <para>To enable message counters, you can set it to <literal>true</literal> in <literal
               >jbm-configuration.xml</literal>:</para>
         <programlisting>
&lt;message-counter-enabled&gt;true&lt;/message-counter-enabled&gt;
         </programlisting>
         <para>Message counters keeps a history of the queue metrics (10 days by default) and
            samples all the queues at regular interval (10 seconds by default). If message counters
            are enabled, these values should be configured to suit your messaging use case in
               <literal>jbm-configuration.xml</literal>:</para>
         <programlisting>
&lt;!-- keep history for a week --&gt;
&lt;message-counter-max-day-history&gt;7&lt;/message-counter-max-day-history&gt;            
&lt;!-- sample the queues every minute (60000ms) --&gt;
&lt;message-counter-sample-period&gt;60000&lt;/message-counter-sample-period&gt;
         </programlisting>
         <para>Message counters can be retrieved using the Management API. For example, to retrieve
            message counters on a JMS Queue using JMX:</para>
         <programlisting>
// retrieve a connection to JBoss Messaging's MBeanServer
MBeanServerConnection mbsc = ...
JMSQueueControlMBean queueControl = (JMSQueueControl)MBeanServerInvocationHandler.newProxyInstance(mbsc,
   on,
   JMSQueueControl.class,
   false);
// message counters are retrieved as a JSON String                                                                                                      
String counters = queueControl.listMessageCounter();
// use the MessageCounterInfo helper class to manipulate message counters more easily
MessageCounterInfo messageCounter = MessageCounterInfo.fromJSON(counters);         
System.out.format("%s message(s) in the queue (since last sample: %s)\n",
   counter.getDepth(),
   counter.getDepthDelta());
         </programlisting>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.message-counters" /> for an example which 
            shows how to use message counters to
            retrieve information on a JMS <literal>Queue</literal>.</para>
      </section>
   </section>
</chapter>
