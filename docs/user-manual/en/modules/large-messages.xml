<?xml version="1.0" encoding="UTF-8"?>
<chapter id="large-messages">
    <title>Large Messages</title>
    <para>JBoss Messaging supports sending and receiving of messages larger than it would fit on
        client or server. The only limit is the disk space available on server.</para>
    <para>Large messages are broken into smaller pieces and sent through the transport and saved as
        files on the server. Flow control (<xref linkend="flow-control"/>) is used on the
        transmission to prevent overusing the channel or running out of memory during the
        transmission process, so it is possible to send and receive very large messages. </para>
    <para>For example, it is possible to send an 8GiB message even if you only had 50MiB of RAM on
        either client and server. </para>
    <section id="large.message.configuring">
        <title>Configuring the server</title>
        <para>Large messages are stored on a disk folder on the server side, as configured on the
            main configuration file.</para>
        <para>The configuration property <literal>large-messages-directory</literal> specifies where
            large messages are stored.</para>
        <programlisting>&lt;configuration xmlns="urn:jboss:messaging"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="urn:jboss:messaging /schema/jbm-configuration.xsd">

...

&lt;large-message-directory> *** type any folder you choose *** &lt;/large-message-directory>

...

&lt;/configuration</programlisting>
        <para>By default the large message directory is <literal>data/largemessages</literal></para>
    </section>
    <section>
        <title>Setting the limits</title>
        <para>The definition of what is a large message is done on the session factory. For example,
            you may configure a factory on the http transport considering a message as large when
            its size is greater than 10KiB and another one on the socket transport considering
            messages greater than 200KiB as large.</para>
        <para>By default the min large message size is 100KiB.</para>
        <section id="large-messages.core.config">
            <title>Using Core API</title>
            <para>If the JBoss Messaging Core API is used, the minimal large message size is
                specified by <literal>ClientSessionFactory.setMinLargeMessageSize</literal>.</para>
            <programlisting>ClientSessionFactory factory = new ClientSessionFactoryImpl(new 
                        TransportConfiguration(NettyConnectorFactory.class.getName()), null);
factory.setMinLargeMessageSize(25 * 1024);</programlisting>
            <para><xref linkend="configuring-transports.client.side"/> will provide more information
                on how to instantiate the session factory.</para>
        </section>
        <section>
            <title>Using JMS</title>
            <para>If JNDI is used to look up the connection factory, the minimal large message size
                is specified in <literal>jbm-jms.xml</literal></para>
            <programlisting>...
&lt;connection-factory name="ConnectionFactory">
&lt;connector-ref connector-name="netty"/>
&lt;entries>
   &lt;entry name="ConnectionFactory"/>
   &lt;entry name="XAConnectionFactory"/>
&lt;/entries>
                
&lt;min-large-message-size>250000&lt;/min-large-message-size>
&lt;/connection-factory>
...</programlisting>
            <para>If the connection factory is being instantiate directly, the minimal large message
                size is specified by <literal
                    >JBossConnectionFactory.setMinLargeMessageSize</literal>.</para>
        </section>
    </section>
    <section>
        <title>Streaming large messages</title>
        <para>JBoss Messaging supports setting the body of messages using input and output streams
                (<literal>java.lang.io</literal>)</para>
        <para>This is a very efficient way of sending and receiving large messages, the stream will
            be used directly by JBoss Messaging during the transmission being a very fast
            process.</para>
        <para>For messages being sent it is possible to set the input stream and as the message is
            being transmitted the input stream is read.</para>
        <para>For messages being received it is possible to set the output stream and as the server
            sends more packets the output stream will receive the body of the message. </para>
        <para>You may choose to block while the output stream is recovered using the method <literal
                >ClientMessage.saveOutputStream</literal>) or do it asynchronously using the method
                <literal>ClientMessage.setOutputstream</literal>. If you choose the non blocking
            method the caller of the method won't wait the transmission to finish after <literal
                >setOutputStream</literal> is called so you need to keep the message consumer
            active.</para>
        <para>You can use any kind of stream you like. The most common use case is to send files
            stored in your disk, but you could also send things like JDBC Blobs, <literal
                >SocketInputStream</literal>, things you recovered from <literal
                >HTTPRequest</literal> etc. Anything as long as it implements <literal
                >java.io.InputStream</literal> for sending messages or <literal
                >java.io.OutputStream</literal> for receiving them.</para>
        <section>
            <title>Streaming over Core API</title>
            <para>The following table shows a list of methods available at <literal
                    >ClientMessage</literal> which are also available through JMS by the use of
                object properties.</para>
            <table frame="topbot" id="large-messages.ClientMessageAPI">
                <title>org.jboss.messaging.core.client.ClientMessage API</title>
                <tgroup cols="3">
                    <colspec colname="Name" colnum="1"/>
                    <colspec colname="Descr" colnum="2"/>
                    <colspec colname="JMS" colnum="3"/>
                    <thead>
                        <row>
                            <entry>Name</entry>
                            <entry>Description</entry>
                            <entry>JMS Equivalent Property</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>setBodyInputStream(InputStream)</entry>
                            <entry>Set the InputStream used on a message that will be sent over a
                                producer</entry>
                            <entry>JMS_JBM_InputStream</entry>
                        </row>
                        <row>
                            <entry>setOutputStream(OutputStream)</entry>
                            <entry>Set the OutputStream that will receive the content of a message
                                received in a non blocking way</entry>
                            <entry>JMS_JBM_OutputStream</entry>
                        </row>
                        <row>
                            <entry>saveOutputStream(OutputStream)</entry>
                            <entry>Save the content of the message to the <literal
                                    >OutputStream</literal>. It will block until the entire content
                                is transferred to the <literal>OutputStream</literal>.</entry>
                            <entry>JMS_JBM_SaveStream</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para> Set the output stream when receiving a core message: </para>
            <programlisting>
...
ClientMessage msg = consumer.receive(...);


// This will block here until the stream was transferred
msg.saveOutputStream(someOutputStream); 

ClientMessage msg2 = consumer.receive(...);

// This will not wait the transfer to finish
msg.setOutputStream(someOtherOutputStream); 
...
                
            </programlisting>
            <para> Set the input stream when sending a core message: </para>
            <programlisting>
...
ClientMessage msg = session.createMessage();
msg.setInputStream(dataInputStream);
...
            </programlisting>
        </section>
        <section id="large-messages.streaming.over.jms">
            <title>Streaming over JMS</title>
            <para>When using JMS JBoss Messaging maps the streaming methods as object properties as
                seen on <xref linkend="large-messages.ClientMessageAPI"/>. You can use the method
                    <literal>Message.setObjectProperty</literal> to set the streaming.</para>
            <para>The <literal>InputStream</literal> can be defined through the JMS Object Property
                JMS_JBM_InputStream on messages being sent:</para>
            <programlisting>
BytesMessage message = session.createBytesMessage();

FileInputStream fileInputStream = new FileInputStream(fileInput);

BufferedInputStream bufferedInput = new BufferedInputStream(fileInputStream);

message.setObjectProperty("JMS_JBM_InputStream", bufferedInput);

someProducer.send(message);</programlisting>
            <para>The <literal>OutputStream</literal> can be set through the JMS Object Property
                JMS_JBM_SaveStream on messages being received in a blocking way.</para>
            <programlisting>
BytesMessage messageReceived = (BytesMessage)messageConsumer.receive(120000);
                
File outputFile = new File("huge_message_received.dat");
                
FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
                
BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutputStream);
                
// This will block until the entire content is saved on disk
messageReceived.setObjectProperty("JMS_JBM_SaveStream", bufferedOutput);
            </programlisting>
            <para>Setting the <literal>OutputStream</literal> could also be done in a non blocking
                way using the property JMS_JBM_InputStream.</para>
            <programlisting>
// This won't wait the stream to finish. You need to keep the consumer active.
messageReceived.setObjectProperty("JMS_JBM_InputStream", bufferedOutput);
            </programlisting>
            <warning>
                <para>When using JMS, Streaming Large Message is only supported on <literal
                        >StreamMessage</literal> and <literal>BytesMessage</literal> because of the
                    extra information required to process other types of messages</para>
            </warning>
        </section>
    </section>
    <section>
        <title>Not using streaming</title>
        <para>You may choose to not use the <literal>InputStream</literal> or <literal
                >OutputStream</literal> capability over JMS or core API even knowing streaming would
            be the most performatic approach. </para>
        <para>You could still access the data transparently both using the core API or JMS.</para>
        <para>On the Core API just get the bytes of the body as you normally would.</para>
        <programlisting>ClientMessage msg = consumer.receive();
         
byte[] bytes = new byte[1024];
for (int i = 0 ;  i &lt; msg.getBodySize(); i += bytes.length)
{
   msg.getBody().readBytes(bytes);
   // Whatever you want to do with the bytes
}</programlisting>
        <para>If using JMS API, <literal>BytesMessage</literal> and <literal>StreamMessage</literal>
            also supports it transparently.</para>
        <programlisting>BytesMessage rm = (BytesMessage)cons.receive(10000);

byte data[] = new byte[1024];

for (int i = 0; i &lt; rm.getBodyLength(); i += 1024)
{
   int numberOfBytes = rm.readBytes(data);
   // Do whatever you want with the data
}        </programlisting>
    </section>
    <section>
        <title>Other Types of Messages</title>
        <para>JBoss Messaging supports large messages of type <literal>TextMessage</literal>,
                <literal>ObjectMessage</literal> and <literal>MapMessage</literal> transparently.
            However those types of message will require a full reconstruction in memory in order to
            work properly.</para>
        <para>For example: You may choose to send a 1MiB String over a TextMessage. When you read
            the message Java will need to parse the body of the message back into a String, so you
            need to have enough memory to allocate your large messages when using those types. If
            you use <literal>BytesMessage</literal> or <literal>StreamMessage</literal> this
            restriction won't apply.</para>
    </section>
    <section>
        <title>Resending a large message</title>
        <para>As large messages are broken into smaller packets, we send them as a streaming from
            server to client. Those message bodies are not kept in memory so once they are read
            their body is gone therefore it is not possible to resend a large message.</para>
        <para>As a result resending large messages after reading them will not work as seen on this
            example:</para>
        <programlisting>BytesMessage bm = (BytesMessage)cons.receive(1000);
                
bm.setObjectProperty("JMS_JBM_SaveStream", bufferedOutput);
                                
/// <emphasis role="bold">This will not work! The body streaming is already gone!</emphasis>
someOtherProducer.send(bm); // resending the message to another destination;            </programlisting>
    </section>
    <section id="large-messages.example">
        <title>Large message example</title>
        <para>The <ulink url="../../../../examples/jms/large-message/readme.html"><literal
                    >large-message</literal> Example</ulink> shows how large message is configured
            and used with JMS.</para>
    </section>
</chapter>
