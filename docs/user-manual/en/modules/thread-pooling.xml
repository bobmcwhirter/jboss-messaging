<?xml version="1.0" encoding="UTF-8"?>
<chapter id="thread-pooling">
    <title>Thread management</title>
    <para>This chapter describes how JBoss Messaging uses and pools thread and how you can manage
        that.</para>
    <para>First we'll discuss how threads are managed and used on the server side, then we'll look
        at the client side.</para>
    <section>
        <title>Server-Side Thread Management</title>
        <para>Each JBoss Messaging Server maintains a single thread pool for general use, and a
            scheduled thread pool for scheduled use. A Java scheduled thread pool cannot be
            configured to use a standard thread pool, otherwise we could use a single thread pool
            for both scheduled and non scheduled activity.</para>
        <para>There are also a small number of other places where threads are used directly, we'll
            discuss each in turn.</para>
        <section id="server.scheduled.thread.pool">
            <title>Server Scheduled Thread Pool</title>
            <para>The server scheduled thread pool is used for most activities on the server side
                that require running periodically or with delays. It maps internally to a <literal
                    >java.util.concurrent.ScheduledThreadPoolExecutor</literal> instance.</para>
            <para>The maximum number of thread used by this pool is configure in <literal
                    >jbm-configuration.xml</literal> with the <literal
                    >scheduled-thread-pool-max-size</literal> parameter. The default value is
                    <literal>5</literal> threads. A small number of threads is usually sufficient
                for this pool.</para>
        </section>
        <section>
            <title>General Purpose Server Thread Pool</title>
            <para>This general purpose thread pool is used for most asynchronous actions on the
                server side. It maps internally to a <literal
                    >java.util.concurrent.ThreadPoolExecutor</literal> instance.</para>
            <para>The maximum number of thread used by this pool is configure in <literal
                    >jbm-configuration.xml</literal> with the <literal
                    >thread-pool-max-size</literal> parameter.</para>
            <para>If a value of <literal>-1</literal> is used this signifies that the thread pool
                has no upper bound and new threads will be created on demand if there are non
                available in the pool to satisfy a request. If activity later subsides then threads
                are timed-out and closed.</para>
            <para>If a value of <literal>n</literal> where <literal>n</literal>is a positive integer
                greater than zero is used this signifies that the thread pool is bounded. If more
                requests come in and there are no free threads in the pool and the pool is full then
                requests will block until a thread becomes available. It is recommended that a
                bounded thread pool is used with caution since it can lead to dead-lock situations
                if the upper bound is chosen to be too low.</para>
            <para>The default value for <literal>thread-pool-max-size</literal> is <literal
                    >-1</literal>, i.e. the thread pool is unbounded.</para>
            <para>See the <ulink
                    url="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.html"
                    >J2SE javadoc</ulink> for more information on unbounded (cached), and bounded
                (fixed) thread pools.</para>
        </section>
        <section>
            <title>Expiry Reaper Thread</title>
            <para>A single thread is also used on the server side to scan for expired messages in
                queues. We cannot use either of the thread pools for this since this thread needs to
                run at its own configurable priority.</para>
            <para>For more information on configuring the reaper, please see the section on message
                expiry [LINK].</para>
        </section>
        <section>
            <title>Asychronous IO</title>
            <para>Two threads are used on Asynchronous IO files. One for polling events, and one for
                writing data. </para>
            <para>The thread poller is used by the native layer to receive and dispatch events. You
                will find it on a thread dump with the prefix JBM-AIO-poller-pool. JBoss Messaging
                uses one poller per opened file on the journal. (there is usually one) and they are
                aways distributed thorugh a pool.</para>
            <para>The writing thread is a single thread used to invoke libaio. We do that to avoid
                context switching on libaio what would cause performance issues. You will find this
                thread on a thread dump with the prefix JBM-AIO-writer-pool.</para>
        </section>
    </section>
    <section>
        <title>Client-Side Thread Management</title>
        <para>On the client side, JBoss Messaging maintains a single static scheduled thread pool
            and a single static general thread pool for use by all clients using the same
            classloader in that JVM instance.</para>
        <para>The static scheduled thread pool has a maximum size of <literal>2</literal> threads,
            and the general purpose thread pool has an unbounded maximum size.</para>
        <para>If required JBoss Messaging can also be configured so that each <literal
                >ClientSessionFactory</literal> instance does not use these static pools but instead
            maintains its own scheduled and general purpose pool. Any sessions created from that
                <literal>ClientSessionFactory</literal> will use those pools instead.</para>
        <para>To configure a <literal>ClientSessionFactory</literal> instance to use its own pools,
            simply use the appropriate setter methods immediately after creation, for
            example:</para>
        <programlisting>
ClientSessionFactory myFactory = new ClientSessionFactory(...);
myFactory.setUseGlobalPools(false);
myFactory.setScheduledThreadPoolMaxSize(10);
myFactory.setThreadPoolMaxSize(-1);            
        </programlisting>
        <para>If you're using the JMS API, you can set the same parameters directly on the <literal
                >JBossConnectionFactory</literal> instance, for example:</para>
        <programlisting>
JBossConnectionFactory myFactory = new JBossConnectionFactory(...);
myFactory.setUseGlobalPools(false);
myFactory.setScheduledThreadPoolMaxSize(10);
myFactory.setThreadPoolMaxSize(-1);                  
        </programlisting>
        <para>If you're using JNDI to instantiate <literal>JBossConnectionFactory</literal>
            instances, you can also set these parameters in the <literal>jbm-jms.xml</literal> file
            where you describe your connection factory, for example:</para>
        <programlisting>
&lt;connection-factory name="ConnectionFactory"&gt;
    &lt;connector-ref connector-name="netty"/&gt;
    &lt;entries&gt;
        &lt;entry name="ConnectionFactory"/&gt;
        &lt;entry name="XAConnectionFactory"/&gt;
    &lt;/entries&gt;
    &lt;use-global-pools&gt;false&lt;/use-global-pools&gt;
    &lt;scheduled-thread-pool-max-size&gt;10&lt;/scheduled-thread-pool-max-size&gt;
    &lt;thread-pool-max-size&gt;-1&lt;/thread-pool-max-size&gt;
&lt;/connection-factory&gt;            
        </programlisting>
    </section>
</chapter>
