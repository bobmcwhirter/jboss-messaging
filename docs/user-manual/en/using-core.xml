<?xml version="1.0" encoding="UTF-8"?>
<chapter id="using-core">
    <title>Using Core</title>
    <para>JBoss Messaging core is a completely JMS agnostic messaging system with its own core
        API.</para>
    <para>If you don't want to use JMS you can use the core API directly. The core API provides all
        the functionality of JMS but without much of the complications. It also provides features
        that are not normally available using JMS.</para>
    <section>
        <title>Core Messaging Concepts</title>
        <para>Some of the core messaging concepts are similar to JMS concepts, but core messaging
            concepts differ in some ways. In general the core messaging API is simpler than the JMS
            API, since we remove distinctions between queues, topics and subscriptions. We'll
            discuss each of the major core messaging concepts in turn:</para>
        <section>
            <title>Message</title>
            <para>A message is the unit of data which is sent between clients and servers.</para>
            <para>A message has a body which is effectively a byte[], it also has a set of
                properties which are key-value pairs. Each property key is a string and property
                values can be of type integer, long, short, byte, byte[], String, double, float or
                boolean.</para>
            <para>A message has a destination which represents the <emphasis>address</emphasis> it
                is being sent to. When the message arrives on the server it is routed to any queues
                that are bound to the address. An address may have many queues bound to it or even
                none.</para>
            <para>Messages can either be durable or non durable. Durable messages in a durable queue
                will survive a server crash or restart. Non durable messages will never survive a
                server crash or restart.</para>
            <para>Messages can be specified with a priority value betwen 0 and 9. 0 represents the
                highest priority and 9 represents the lowest. JBoss Messaging will attempt to
                deliver higher priority messages before lower priority ones.</para>
            <para>Messages can be specified with an optional expiry time. JBoss Messaging will not
                deliver messages after its expiry time has been exceeded.</para>
            <para>Messages also have an optional timestamp which represents the time the message was
                sent.</para>
        </section>
        <section>
            <title>Address</title>
            <para>A server maintains a mapping between an address and a set of queues. Zero or more
                queues can be bound to a single address. Each queue can be bound with an optional
                message filter. When a message is routed to an address it is routed to the set of
                queues bound to the message's destination address. If any of the queues are bound
                with a filter expression, then the message will only be routed to the subset of
                bound queues which match that filter expression.</para>
            <note>
                <para>In core, there is no concept of a Topic, Topic is a JMS only term. Instead, in
                    core, we just deal with <emphasis>addresses</emphasis> and
                        <emphasis>queues</emphasis>.</para>
                <para>For example, a JMS topic would implemented by a single address to which many
                    queues are bound. Each queue represents a subscription of the topic. A JMS Queue
                    would be implemented as a single address to which one queue is bound - that
                    queue represents the JMS queue.</para>
            </note>
        </section>
        <section>
            <title>Queue</title>
            <para>Queues can be durable, meaning the messages they contain survive a server crash or
                restart, as long as the messages in them are durable. Non durable queues do not
                survive a server restart or crash even if the messages they contain are
                durable.</para>
            <para>Queues can also be temporary, meaning they are automatically deleted when the
                client connection is closed, if they are not explicitly deleted before that.</para>
            <para>Queues can be bound with an optional filter expression. If a filter expression is
                supplied then the server will only route messages who match that filter expression
                to any queues bound to the address.</para>
            <para>Many queues can be bound to a single address. A particular queue is only bound to
                a maximum of one address.</para>
        </section>
        <section>
            <title>ClientSessionFactory</title>
            <para>Clients use <literal>ClientSessionFactory</literal> instances to create
                    <literal>ClientSession</literal> instances.
                    <literal>ClientSessionFactory</literal> instances know how to connect to the
                server to create sessions.</para>
        </section>
        <section>
            <title>ClientSession</title>
            <para>A client uses a ClientSession for consuming and producing messages and for
                grouping them in transactions. ClientSession instances can support both
                transactional and non transactional semantics and also provide an
                    <literal>XAResource</literal> interface so messaging operations can be performed
                as part of a JTA transaction.</para>
            <para>ClientSession instances group ClientConsumers and ClientProducers.</para>
        </section>
        <section>
            <title>ClientConsumer</title>
            <para>Clients use <literal>ClientConsumer</literal> instances to consume messages from a
                queue. Core Messaging supports both synchronous and asynchronous message consumption
                semantics. <literal>ClientConsumer</literal> instances can be configured with an
                optional filter expression and will only consume messages which match that
                expression.</para>
        </section>
        <section>
            <title>ClientProducer</title>
            <para>Clients create <literal>ClientProducer</literal> instances on
                    <literal>ClientSession</literal> instances so they can send messages.
                ClientProducer instances can specify an address to which all sent messages are
                routed, or they can have no specified address, and the address is specified at send
                time for the message.</para>
        </section>
    </section>
    <section>
        <title>A simple example of using Core</title>
        <para>Here's a very simple program using the core messaging API to send and receive a
            message:</para>
        <programlisting>ClientSessionFactory nettyFactory =  new ClientSessionFactoryImpl(
                      new TransportConfiguration(
                              InVMConnectorFactory.class.getName()), null);

ClientSession session = nettyFactory.createSession();
session.createQueue("example", "example", true);

ClientProducer producer = session.createProducer("example");
ClientMessage message = session.createClientMessage(true);

message.getBody().writeString("Hello");

producer.send(message);

session.start();

ClientConsumer consumer = session.createConsumer("example");

ClientMessage msgReceived = consumer.receive();
System.out.println("message = " + msgReceived.getBody().readString());

session.close();</programlisting>
    </section>
</chapter>
