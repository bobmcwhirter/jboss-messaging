<chapter id="UG2_configuration">
  <title>Configuration</title>

  <para>The JMS API specifies how a messaging client interacts with a messaging server. The exact definition and implementation of messaging services, such as message destinations and connection factories, are specific to JMS providers. JBoss Messaging has its own configuration files to configure services. If you are migrating services from JBossMQ (or other JMS provider) to JBoss Messaging, you will need to understand those configuration files.</para>

  <para>In this chapter, we discuss how to configure various services inside JBoss Messaging, which work together to provide JMS API level
     services to client applications.</para>

   <para>
      Starting with the JBoss Messaging 1.0.1 release, the service configuration is spread among several configuration files.
      (The 1.0.0 release used to have all configuration information lumped together in the SAR's deployment
      descriptor <filename>jboss-messaging.sar/META-INF/jboss-service.xml</filename>). Depending
      on the functionality provided by the services it configures, the configuration data is
      distributed between
      <filename>messaging-service.xml</filename>,
      <filename>remoting-service.xml</filename>,
      <filename>xxx-persistence-service.xml</filename>,
      <filename>connection-factories-service.xml</filename> and
      <filename>destinations-service.xml</filename>.
   </para>

   <para>
      The AOP client-side and server-side interceptor stacks are configured in
      <filename>aop-messaging-client.xml</filename> and <filename>aop-messaging-server.xml</filename>.
   </para>

  <section id="conf.serverpeer">
    <title>Configuring the Server</title>

    <para>
       The Server Peer is the "heart" of the JBoss Messaging JMS facade. The server's configuration,
       together with the configuration of several core plug-ins (ThreadPool and the
       MessageStore), resides in <filename>messaging-service.xml</filename> configuration file.
    </para>


     <para>An example of a Server Peer configuration is presented below</para>

     <programlisting>

  &lt;mbean code="org.jboss.jms.server.ServerPeer"
      name="jboss.messaging:service=ServerPeer"
      xmbean-dd="xmdesc/ServerPeer-xmbean.xml"&gt;

      &lt;constructor&gt;
         &lt;!-- ServerPeerID --&gt;
         &lt;arg type="java.lang.String" value="server.0"/&gt;
         &lt;!-- DefaultQueueJNDIContext --&gt;
         &lt;arg type="java.lang.String" value="/queue"/&gt;
         &lt;!-- DefaultTopicJNDIContext --&gt;
         &lt;arg type="java.lang.String" value="/topic"/&gt;
      &lt;/constructor&gt;

      &lt;depends optional-attribute-name="ThreadPool"&gt;jboss.messaging:service=ThreadPool&lt;/depends&gt;
      &lt;depends optional-attribute-name="PersistenceManager"&gt;jboss.messaging:service=PersistenceManager&lt;/depends&gt;
      &lt;depends optional-attribute-name="MessageStore"&gt;jboss.messaging:service=MessageStore&lt;/depends&gt;
      &lt;depends optional-attribute-name="ChannelMapper"&gt;jboss.messaging:service=ChannelMapper&lt;/depends&gt;

      &lt;!-- Set to -1 to completely disable client leasing --&gt;
      &lt;attribute name="SecurityDomain"&gt;java:/jaas/messaging&lt;/attribute&gt;
      &lt;attribute name="DefaultSecurityConfig"&gt;
        &lt;security&gt;
            &lt;role name="guest" read="true" write="true" create="true"/&gt;
        &lt;/security&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;

     </programlisting>

     <section id="conf.serverpeer.securitydomain">
        <title>SecurityDomain</title>

        <para>
           This identifies the JBoss security domain that will be used when JBoss Messaging
           authenticates and authorises access to JMS destinations for reading, writing or
           creating.
        </para>

        <para>
           It should correspond to a entry in <filename>login-config.xml</filename> where
           it is configured in exactly the same way as any other security domain in JBoss.
        </para>
     </section>

     <section id="conf.serverpeer.defaultsecurity">
        <title>DefaultSecurityConfig</title>

        <para>
           Default security configuration is used when the security configuration for a specific
           queue or topic has not been overridden in the destination's deployment descriptor.
           It has exactly the same syntax and semantics as in JBossMQ.
        </para>

        <para>
           The <literal>DefaultSecurityConfig</literal> attribute element should contain
           one <literal>&lt;security&gt;</literal> element.
           The <literal>&lt;security&gt;</literal> element can contain multiple
           <literal>&lt;role&gt;</literal> elements. Each <literal>&lt;role&gt;</literal>
           element defines the default access for that particular role.
        </para>

        <para>
           If the <literal>read</literal> attribute is <literal>true</literal> then that role
           will be able to read (create consumers, receive messaages or browse) destinations
           by default.
        </para>

        <para>
           If the <literal>write</literal> attribute is <literal>true</literal> then that role
           will be able to write (create producers or send messages) to destinations by default.
        </para>

        <para>
           If the <literal>create</literal> attribute is <literal>true</literal> then that role
           will be able to create durable subscriptions on topics by default.
        </para>
     </section>
  </section>


  <section id="conf.persistence">
    <title>Configuring Persistence</title>

    <para>
       JBoss Messaging interacts with a persistent store via two services: the Persistence Manager
       and the Channel Mapper. The Persistence Manager is used to handle the message-related
       functions. The Channel Mapper manages destination-related persistent
       data.
    </para>

    <para>
       JBoss Messaging ships with a JDBC Persistence Manager used for handling persistence of
       message data in a relational database accessed via JDBC. The Persistence Manager
       implementation is pluggable (the Persistence Manager is a Messaging server plug-in),
       this making possible to provide other implementations for persisting message data in
       non relational stores, file stores etc.
    </para>

     <para>
        The configuration of "persistent" services is grouped in a
        <filename>xxx-persistence-service.xml</filename> file, where the actual file prefix is
        usually inferred from its corresponding database JDBC connection string. By default,
        Messaging ships with a <filename>hsqldb-persistence-service.xml</filename>, which configures
        the Messaging server to use the in-VM Hypersonic database instance that comes by default
        with any JBossAS instance.
     </para>

     <warning>
        <para>
        The default Persistence Manager configuration is works out of the box with Hypersonic,
        however it must be stressed that Hypersonic should not be used in a production environment
        mainly due to its limited support for transaction isolation and its propensity to behave
        erratically under high load.
        </para>
        <para>
           The
           <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=ConfigJBossMQDB">Critique of Hypersonic</ulink>
           wiki page outlines some of the well-known issues occuring when using this database.
        </para>
     </warning>

     <para>
        JBoss Messaging also ships with pre-made Persistence Manager configurations for MySQL,
        Oracle, PostgreSQL and Sybase. The example <filename>mysql-persistence-service.xml</filename>,
        <filename>oracle-persistence-service.xml</filename>,
        <filename>postgres-persistence-service.xml</filename> and
        <filename>sybase-persistence-service.xml</filename> configuration files are available
        in the <filename>examples/config</filename> directory of the release bundle.
     </para>

     <para>
        Configurations for MSSQL and other popular databases should be available soon. Users are
        encouraged to contribute their own configuration files. The JDBC Persistence Manager has been designed
        to use standard SQL for the DML so writing a JDBC Persistence Manager configuration for another
        database is usually only a fairly simple matter of changing DDL in the configuration
        which is likely to be different for different databases.
     </para>

     <para>
        The default Hypersonic persistence configuration file is listed below:
     </para>

     <programlisting>
&lt;server&gt;
   &lt;mbean code="org.jboss.messaging.core.plugin.JDBCPersistenceManager"
      name="jboss.messaging:service=PersistenceManager"
      xmbean-dd="xmdesc/JDBCPersistenceManager-xmbean.xml"&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;depends optional-attribute-name="ChannelMapper"&gt;jboss.messaging:service=ChannelMapper&lt;/depends&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
      &lt;attribute name="UsingBatchUpdates"&gt;true&lt;/attribute&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.plugin.JDBCChannelMapper"
      name="jboss.messaging:service=ChannelMapper"
      xmbean-dd="xmdesc/JDBCChannelMapper-xmbean.xml"&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
   &lt;/mbean&gt;
&lt;/server&gt;
     </programlisting>

     <para>
        An example of a Persistence Manager configuration for a MySQL database follows:
     </para>

  <programlisting>
&lt;server&gt;
   &lt;mbean code="org.jboss.messaging.core.plugin.JDBCPersistenceManager"
      name="jboss.messaging:service=PersistenceManager"
      xmbean-dd="xmdesc/JDBCPersistenceManager-xmbean.xml"&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;depends optional-attribute-name="ChannelMapper"&gt;jboss.messaging:service=ChannelMapper&lt;/depends&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
      &lt;attribute name="UsingBatchUpdates"&gt;true&lt;/attribute&gt;
      &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
CREATE_MESSAGE_REF=CREATE TABLE JMS_MESSAGE_REFERENCE (CHANNELID BIGINT, MESSAGEID BIGINT, TRANSACTIONID BIGINT, STATE CHAR(1), ORD BIGINT, DELIVERYCOUNT INTEGER, RELIABLE CHAR(1), LOADED CHAR(1), PRIMARY KEY(CHANNELID, MESSAGEID))
CREATE_IDX_MESSAGE_REF_TX=CREATE INDEX JMS_MESSAGE_REF_TX ON JMS_MESSAGE_REFERENCE (TRANSACTIONID)
CREATE_IDX_MESSAGE_REF_ORD=CREATE INDEX JMS_MESSAGE_REF_ORD ON JMS_MESSAGE_REFERENCE (ORD)
CREATE_IDX_MESSAGE_REF_MESSAGEID=CREATE INDEX JMS_MESSAGE_REF_MESSAGEID ON JMS_MESSAGE_REFERENCE (MESSAGEID)
CREATE_IDX_MESSAGE_REF_LOADED=CREATE INDEX JMS_MESSAGE_REF_LOADED ON JMS_MESSAGE_REFERENCE (LOADED)
CREATE_IDX_MESSAGE_REF_RELIABLE=CREATE INDEX JMS_MESSAGE_REF_RELIABLE ON JMS_MESSAGE_REFERENCE (RELIABLE)
INSERT_MESSAGE_REF=INSERT INTO JMS_MESSAGE_REFERENCE (CHANNELID, MESSAGEID, TRANSACTIONID, STATE, ORD, DELIVERYCOUNT, RELIABLE, LOADED) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
....      ]]&gt;
      &lt;/attribute&gt;
      &lt;attribute name="MaxParams"&gt;500&lt;/attribute&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.plugin.JDBCChannelMapper"
      name="jboss.messaging:service=ChannelMapper"
      xmbean-dd="xmdesc/JDBCChannelMapper-xmbean.xml"&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
CREATE_USER_TABLE=CREATE TABLE JMS_USER (USERID VARCHAR(32) NOT NULL, PASSWD VARCHAR(32) NOT NULL, CLIENTID VARCHAR(128), PRIMARY KEY(USERID))
CREATE_ROLE_TABLE=CREATE TABLE JMS_ROLE (ROLEID VARCHAR(32) NOT NULL, USERID VARCHAR(32) NOT NULL, PRIMARY KEY(USERID, ROLEID))
SELECT_PRECONF_CLIENTID=SELECT CLIENTID FROM JMS_USER WHERE USERID=?
....
      ]]&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;
&lt;/server&gt;
  </programlisting>

     <section id="conf.changingds">
        <title>Changing the Database</title>

        <para>
           If the database you want to switch to is one of MySQL, Oracle or Postgres,
           persistence configuration files are already available in
           the <filename>examples/config</filename> directory of the release bundle.
        </para>

        <para>
           In order to enable support for one of these databases, just replace the default
           <filename>hsqldb-persistence-service.xml</filename> configuration file with the
           database-specific configuration file and restart the server.
        </para>

        <para>
           Also, be aware that by default, the Messaging services relying on a datastore
           are referencing <literal>"java:/DefaultDS"</literal> for the datasource.
           If you are deploying a datasource with a different JNDI name, you need to update
           all the <literal>DataSource</literal> attribute in the persistence configuration file.
        </para>

     </section>

     <section id="conf.persistence.createtables">
        <title>CreateTablesOnStartup</title>

        <para>
           Set this to <literal>true</literal> if you wish the Persistence Manager to attempt
           to create the tables (and indexes) when it starts. If the tables (or indexes)
           already exist a <literal>SQLException</literal> will be thrown by the JDBC driver and
           ignored by the Persistence Manager, allowing it to continue.
        </para>
        <para>
           By default the value of <literal>CreateTablesOnStartup</literal> attribute
           is set to <literal>true</literal>
        </para>
  </section>

   <section id="conf.persistence.batchupdates">
        <title>UsingBatchUpdates</title>

        <para>
           Set this to <literal>true</literal> if the database supports JDBC batch updates.
           The JDBC Persistence Manager will then group multiple database updates in batches
           to aid performance.
        </para>
      <para>
         By default the value of <literal>UsingBatchUpdates</literal> attribute
         is set to <literal>false</literal>
      </para>
    </section>

     <section id="conf.persistence.sqlproperties">
        <title>SQLProperties</title>

        <para>
           This is where the DDL and DML for the particular database is specified.
           If a particular DDL or DML statement is not overridden, the default Hypersonic
           configuration will be used for that statement.
        </para>
     </section>

  </section>

  <section id="conf.destination">
    <title>Configuring Destinations</title>

     <section id="conf.preconf.destinations">
        <title>Pre-configured destinations</title>

        <para>
           JBoss Messaging  ships with a default set of pre-configured destinations that will be
           deployed during the server start up. The file that contains configuration for these
           destinations is <filename>destinations-service.xml</filename>. A section of
           this file is listed below:
        </para>

        <programlisting>

&lt;!-- The Dead Letter Queue. This destination is a dependency of an EJB MDB container --&gt;

&lt;mbean code="org.jboss.jms.server.destination.Queue"
       name="jboss.messaging.destination:service=Queue,name=DLQ"
       xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
   &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
&lt;/mbean&gt;

....

&lt;mbean code="org.jboss.jms.server.destination.Topic"
       name="jboss.messaging.destination:service=Topic,name=testTopic"
       xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
   &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
   &lt;attribute name="SecurityConfig"&gt;
      &lt;security&gt;
         &lt;role name="guest" read="true" write="true"/&gt;
         &lt;role name="publisher" read="true" write="true" create="false"/&gt;
         &lt;role name="durpublisher" read="true" write="true" create="true"/&gt;
      &lt;/security&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;

....

&lt;mbean code="org.jboss.jms.server.destination.Queue"
       name="jboss.messaging.destination:service=Queue,name=testQueue"
       xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
   &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
   &lt;attribute name="SecurityConfig"&gt;
      &lt;security&gt;
         &lt;role name="guest" read="true" write="true"/&gt;
         &lt;role name="publisher" read="true" write="true" create="false"/&gt;
         &lt;role name="noacc" read="false" write="false" create="false"/&gt;
      &lt;/security&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;

....
        </programlisting>

     </section>

     <section id="conf.destination.config.paramters">
        <title>Destination Configuration Parameters</title>

        <section id="conf.destination.security">
         <title>Destination Security Configuration</title>

           <para>
              <literal>SecurityConfig</literal> - allows you to determine which roles are allowed
              to read, write and create on the destination. It has exactly the same syntax and
              semantics as the security configuration in JBossMQ destinations.
           </para>

           <para>
              The <literal>SecurityConfig</literal> element should contain one
              <literal>&lt;security&gt;</literal> element. The <literal>&lt;security&gt;</literal>
              element can contain multiple <literal>&lt;role&gt;</literal> elements.
              Each <literal>&lt;role&gt;</literal> element defines the access for that
              particular role.
           </para>

           <para>
              If the <literal>read</literal> attribute is <literal>true</literal> then that role
              will be able to read (create consumers, receive messaages or browse) this destination.
           </para>

           <para>
              If the <literal>write</literal> attribute is <literal>true</literal> then that role
              will be able to write (create producers or send messages) to this destination.
           </para>

           <para>
              If the <literal>create</literal> attribute is <literal>true</literal> then that role
              will be able to create durable subscriptions on this destination.
           </para>

           <para>
              Note that the security configuration for a destination is optional. If a
              <literal>SecurityConfig</literal> element is not specifed then the default
              security configuration from the Server Peer will be used.
           </para>
        </section>

        <section id="conf.destination.paging">
           <title>Destination paging parameters</title>

           <para>
              'Pageable Channels' are a sophisticated new feature available in JBoss Messaging.
           </para>

           <para>
              If your application needs to support very large queues or subscriptions containing
              potentially millions of messages, then it's not possible to store them all in
              memory at once.
           </para>

           <para>
              JBoss Messaging solves this problem but letting you specify the
              maximum number of messages that can be stored in memory at any one time,
              on a queue-by-queue, or topic-by-topic basis. JBoss Messaging then pages messages
              to and from storage transparently in blocks, allowing queues and subscriptions to
              grow to very large sizes without any performance degradation as channel size increases.
           </para>

           <para>
              This has been tested with in excess of 10 million 2K messages on very basic hardware
              and has the potential to scale to much larger number of messages.
           </para>

           <para>
              The individual parameters are:
           </para>

           <para>
              <literal>FullSize</literal> - this is the maximum number of messages held by the
              queue or topic subscriptions in memory at any one time. The actual queue or
              subscription can hold many more messages than this but these are paged to and
              from storage as necessary as messages are added or consumed.
           </para>

           <para>
              <literal>PageSize</literal> - When loading messages from the queue or subscrition
              this is the maximum number of messages to pre-load in one operation.
           </para>

           <para>
              <literal>DownCacheSize</literal> - When paging messages to storage from the queue
              they first go into a "Down Cache" before being written to storage. This enables the
              write to occur as a single operation thus aiding performance. This setting determines
              the max number of messages that the Down Cache will hold before they are flushed
              to storage.
           </para>

           <para>
              If no values for <literal>FullSize</literal>, <literal>PageSize</literal>,
              or <literal>DownCacheSize</literal> are specified they will default to values
              75000, 2000, 2000 respectively.
           </para>

           <para>
              If you want to specify the paging parameters used for temporary queues then you need to specify them
              on the appropriate connection factory.
              See connection factory configuration for details.
           </para>
        </section>
     </section>

     <section id="conf.destination.new">
        <title>Deploying a new destination</title>

        <para>
           For a JBoss 4.0.x installation, JBoss Messaging is deployed in its own class
           loading domain. Because of that you need to deploy a new destinations to use
           with JBoss Messaging within the same class loading domain.
       </para>

        <para>
           To deploy a new destination, create a new deployment descriptor named
           <filename>myqueue-service.xml</filename> (or anything else that ends in
           <literal>-service.xml</literal>) and copy it to the JBoss instance deployment
           directory <filename>$JBOSS_HOME/server/messaging/deploy</filename>.
        </para>

        <para>
           An example of a scoped destination deployment descriptor is listed below:
        </para>

        <programlisting>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;server&gt;
 &lt;loader-repository&gt;jboss.messaging:loader=ScopedLoaderRepository
 &lt;loader-repository-config&gt;java2ParentDelegation=false&lt;/loader-repository-config&gt;
 &lt;/loader-repository&gt;
 &lt;mbean code=&quot;org.jboss.jms.server.destination.Queue&quot;
           name=&quot;jboss.messaging.destination:service=Queue,name=testQueue&quot;
           xmbean-dd=&quot;xmdesc/Queue-xmbean.xml&quot;&gt;
           &lt;depends optional-attribute-name=&quot;ServerPeer&quot;&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
           &lt;attribute name=&quot;SecurityConfig&quot;&gt;
              &lt;security&gt;
                 &lt;role name=&quot;guest&quot; read=&quot;true&quot; write=&quot;true&quot;/&gt;
                 &lt;role name=&quot;publisher&quot; read=&quot;true&quot; write=&quot;true&quot; create=&quot;false&quot;/&gt;
                 &lt;role name=&quot;noacc&quot; read=&quot;false&quot; write=&quot;false&quot; create=&quot;false&quot;/&gt;
               &lt;/security&gt;
           &lt;/attribute&gt;
           &lt;attribute name=&quot;fullSize&quot;&gt;75000&lt;/attribute&gt;
           &lt;attribute name=&quot;pageSize&quot;&gt;2000&lt;/attribute&gt;
           &lt;attribute name=&quot;downCacheSize&quot;&gt;2000&lt;/attribute&gt;
 &lt;/mbean&gt;
&lt;/server&gt;
        </programlisting>

     </section>
  </section>

  <section id="conf.connections">
    <title>Configuring Connection Factories</title>

    <para>
       With the default configuration JBoss Messaging binds just one connection factory in
       JNDI at start-up. This connection factory has no client ID and is bound into the
       following JNDI contexts:
       <literal>/ConnectionFactory, /XAConnectionFactory, java:/ConnectionFactory, java:/XAConnectionFactory</literal>
    </para>

    <para>
       You may want to configure additional connection factories, for instance if you want to provide
       a default client id for a connection factory, or if you want to bind it in different places
       in JNDI, or if you want different connection factories to use different transports. Deploying
       a new connection factory is equivalent with adding a new ConnectionFactory MBean
       configuration to <filename>connection-factories-service.xml</filename>.
    </para>
     <para>
        It is also possible to create an entirely
        new service deployment descriptor <filename>xxx-service.xml</filename> altogether and
        deploy it in <filename>$JBOSS_HOME/server/messaging/deploy</filename>.
    </para>

    <para>
       An example connection factory configuration is presented below:
     </para>

      <programlisting>
     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
     &lt;server&gt;
        &lt;loader-repository&gt;jboss.messaging:loader=ScopedLoaderRepository
           &lt;loader-repository-config&gt;java2ParentDelegation=false&lt;/loader-repository-config&gt;
        &lt;/loader-repository&gt;
        &lt;mbean code=&quot;org.jboss.jms.server.connectionfactory.ConnectionFactory&quot;
           name=&quot;jboss.messaging.destination:service=ConnectionFactory&quot;
           xmbean-dd=&quot;xmdesc/ConnectionFactory-xmbean.xml&quot;&gt;
           &lt;constructor&gt;
              &lt;arg type=&quot;java.lang.String&quot; value=&quot;myClientID&quot;/&gt;
           &lt;/constructor&gt;
           &lt;depends optional-attribute-name=&quot;ServerPeer&quot;&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
           &lt;depends optional-attribute-name=&quot;Connector&quot;&gt;jboss.messaging:service=Connector,transport=socket&lt;/depends&gt;
           &lt;attribute name=&quot;PrefetchSize&quot;&gt;10&lt;/attribute&gt;
           &lt;attribute name=&quot;DefaultTempQueueFullSize&quot;&gt;1000&lt;/attribute&gt;
           &lt;attribute name=&quot;DefaultTempQueuePageSize&quot;&gt;50&lt;/attribute&gt;
           &lt;attribute name=&quot;DefaultTempQueueDownCacheSize&quot;&gt;50&lt;/attribute&gt;
           &lt;attribute name=&quot;JNDIBindings&quot;&gt;
              &lt;bindings&gt;
                 &lt;binding&gt;/MyConnectionFactory1&lt;/binding&gt;
                 &lt;binding&gt;/factories/cf1&lt;/binding>&gt;
              &lt;/bindings&gt;
           &lt;/attribute&gt;
        &lt;/mbean&gt;
     &lt;/server&gt;

    </programlisting>

     <para>
        The above example would create a connection factory with pre-configured client ID
        <literal>myClientID</literal> and bind the connection factory in two places in
        the JNDI tree: <literal>/MyConnectionFactory</literal>
        and <literal>/factories/cf</literal>. The connection factory will use the default
        remoting connector. To use a different remoting connector with the connection factory
        change the <literal>Connector</literal> attribute to specify the service name of the connector you wish to use.
    </para>
    <para>prefetchSize is an optional attribute that determines how many messages client side message consumers will buffer locally. Pre-fetching messages prevents
    the client having to go to the server each time a message is consumed to say it is ready to receive another message.
    This greatly increases throughput. The default value for prefetchSize is 150. You may want to change this to a smaller value if you are dealing with
    very large messages, so as not to use too much memory on the client.
    </para>
    <para>DefaultTempQueueFullSize, DefaultTempQueuePageSize, DefaultTempQueueDownCacheSize are optional attributes that determine the default paging parameters to be used for
    any temporary destinations scoped to connections created using this connection factory. See the section on paging channels for more information
    on what these values mean.
    They will default to values of 75000, 2000 and 2000 respectively if ommitted.
    </para>
  </section>

  <section id="conf.connector">
      <title>Configuring the remoting connector</title>

      <para>
         JBoss Messaging uses JBoss Remoting  for all client to server communication.
         For full details of what JBoss Remoting is capable of and how it is configured please
         consult the JBoss Remoting documentation.
      </para>

      <para>
         The default configuration includes a single remoting connector which is used by the
         single default connection factory. Each connection factory can be configured to use
         its own connector.
      </para>

      <para>
         The default connector is configured to use the remoting socket transport.
      </para>

      <para>
         This transport opens TCP connections from client to server for client to server
         communications (e.g. sending messages) and TCP connections from server to client
         for server to client communications (e.g. receiving messages). The transport can be
         configured to use SSL where a higher level of security is required.
      </para>

      <para>
        Future releases JBoss Messaging will support a bidirectional socket transport
         (similar to UIL2 in JBoss MQ) and an HTTP transport, both of which are useful in
         network environments where TCP connections from server to client are not possible.
         This means, for example, that you could deploy one connection factory that uses
         the HTTP transport for all the connections created from it, and another connection
         factory that uses the socket transport for all connections created from it.
      </para>

       <para>
         You can look at remoting configuration under:
       </para>

       <para>
          &lt;JBoss&gt;/server/&lt;YourMessagingServer&gt;/deploy/jboss-messaging.sar/remoting-service.xml
       </para>
       
       <para>
          By default JBoss Messaging binds to ${jboss.bind.address} which can be defined by:
          ./run.sh -c &lt;yourconfig&gt; -b yourIP.
       </para>

       <para>
          You can change remoting-service.xml if you want for example use a
          different communication port, or change any other network behavior.
       </para>
  </section>

  <section id="conf.callback">
      <title>Configuring the callback</title>

      <para>
         JBoss Messaging uses a callback mechanism from Remoting that needs a Socket for callback operations. These socket properties are passed to the server by a remote call when the connection is being estabilished. As we said before we will support bidirectional protocols in future releases.
      </para>

      <para>
         By default JBoss Messaging will execute InetAddress.getLocalHost().getHostAddress() to access your local host IP, but in case you need to setup a different IP, you can define a system property in your java arguments: 
      </para>

      <para>
		Use java -Djboss.messaging.callback.bind.address=YourHost - That will determine the callBack host in your client.
      </para>

      <para>
		The client port will be selected randomly for any non used port. But if you defined -Djboss.messaging.callback.bind.port=NumericPort in your System Properties that number is going to be used for the call back client port.
      </para>

  </section>
</chapter>
