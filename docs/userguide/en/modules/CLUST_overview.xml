<chapter id="CLUST_overview">


   <title>JBoss Messaging Clustering</title>

    <para>
      This section of the userguide gives a brief overview of the features available in
        JBoss Messaging Clustering 1.2.0.GA. It gives a high level explanation of how
        clustering works.
     </para>

   <section id="clustering_overview">
      <title>JBoss Messaging Clustering Overview</title>

      <para>
      Here's a brief overview of how clustering works in JBoss Messaging 1.2.
      </para>


      <para>
      Clustered destinations (queues and topics) can be deployed at all or none of the nodes of
      the cluster.
      A JMS client uses HA JNDI to lookup the connection factory. A client side load balancing
      policy will automatically chose a node to connect to (This is similar to
      how EJB clustering chooses a node).
      </para>

      <para>
      The JMS client has now made a connection to a node where it can create sessions, message
      producers and message consumers and browsers and send or consume messages,
      using the standard JMS api.
      When a distributed queue is deployed across the cluster, individual partial queues are
      deployed on each node.
      </para>

      <para>
      When a message is sent from a message producer attached to a particular node to a
      distributed queue, a routing policy determines which partial queue will receive
      the message.
      By default the router will always pass the message to a local queue, if there is one,
      this is so we avoid unnecessary network traffic.
      If there is no local queue then a partial queue on a different node will be chosen by the
      router, by default this will be round robin between remote partial queues.
      </para>

      <para>
      When a message is sent to a distributed topic while attached to a node, there may be
      multiple subscriptions on different nodes that need to receive the
      message. Depending on the number and location of subscriptions, the message may be multicast
      or unicast across the cluster so the other nodes can pick it up.
      (All group communication, unicast, multicast and group management is handled by JGroups.)
      </para>

      <para>
      In the case of shared durable subscriptions, if a durable subscription with the same name
      exists on more than node, then only one of the instances needs to receive the message.
      Which one is determined by the same routing policy used to route messages to partial queues.
      All of this is accomplished without losing the reliability guarantees required by JMS.
      </para>

      <para>
      Subscriptions (both durable and non durable) can be created on all nodes and will receive messages sent via any node.
      What happens if the consumers on one queue/subscription are faster/slower than consumers on another?
      Normally this would result in messages building up on that queue and fast consumers being starved of work on another, thus wasting CPU cycles on the node that
      could be put to good use.
      The most degenerate example is of a queue containing many messages then the consumers being closed on that queue.
      The messages might potentially remain stranded on the queue until another consumer attaches.
      A routing policy is no use here, since the messages have already been routed to the queuee and the consumers closed / slowed down
      after they were routed there.
      JBoss Messaging can deal with this problem by intelligently pulling messages from other less
      busy nodes, if it detects idle consumers on the fast node and slow consumers
      on another node.
      </para>

      <para>
      Normally, persistent messages are persisted in a shared database which is shared by all nodes
      in the cluster.

      JBoss Messaging 1.2.1 will contain
      an option where you can choose to not persist persistent messages in a database, but instead to replicate them between nodes of the cluster.

      The idea here is the network IO on a fast network should be much faster than persisting to disk.
      This solution should also be more scalable since different nodes replicate their messages onto
      different other nodes - there is no "master node".

      If the messages are replicated onto sufficient nodes and the hardware is set-up with UPS, then we believe a comparable reliability guarantee to persisting messages to disk
      can be achieved. Of course, this won't be suitable for all situations, but you use the best tool for the job.
      </para>

   </section>


    <section id="clustering_architectural_overview">
        <title>Clustering Architectural Overview</title>

        <para>
           One of the fundamental Messaging Core building blocks is the "Post Office". A JBoss Messaging
           Post Office is message routing component, which accepts messages for delivery and synchronously
           forwards them to their destination queues or topic subscriptions.
        </para>

        <para>
           There is a single Post Office instance per JBoss Messaging server (cluster node). Both queues
           and topics deployed on a JBoss Messaging node are "plugged" into that Post Office instance.
           Internally JBoss Messaging only deals  with the concepts of queues, and considers a topic to
           just be a set of queues (one for each subscription). Depending on the type of subscription -
           durable or non-durable - the corresponding queue saves messages to persistent storage or
           it just holds messages in memory and discards them when the non-durable subscription is closed.
        </para>

        <para>
           Therefore, for a JMS queue, the Post Office routes messages to one and only one core queue,
           depending on the queue name, whereas for a JMS topic, the Post Office routes a message
           to a set of core queues, one for each topic subscription, depending on the topic name.
        </para>

        <para>
           Clustering across multiple address spaces is achieved by clustering Post Office instances. Each
           JBoss Messaging cluster node runs a Clustered Post Office instance, which is aware of the presence
           of all other clustered Post Offices in the cluster. There is an one-to-one relationship between cluster
           nodes and clustered Post Office instances. So, naturally, the most important piece of clustering
           configuration is the <emphasis>clustered Post Office service configuration</emphasis>,
           covered in detail below.
        </para>

        <para>
           Clustered Post Office instances connect to each other via JGroups and they heavily rely on JGroups
           group management and notification mechanisms. <emphasis>JGroups stack configuration</emphasis>
           is an essential part of JBoss Messaging clustering configuration. JGroups configuration is only
           briefly addressed in this guide. Detailed information on JGroups can be found in JGroups
           release documentation or on-line at <ulink url="http://www.jgroups.org">http://www.jgroups.org</ulink>
           or <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups">http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups</ulink>
        </para>

        <para>
           When routing messages, a clustered Post Office  has a choice of forwarding the message to local
           queues or remote queues, plugged into remote Post Office instances that are part of the same
           cluster. Local queues are usually preferred, but if a local queue is part of a distributed queue, has
           no consumers, and other local queues part of the same distributed queue have consumers, messages
           can be automatically redistributed, subject of the message redistribution policy in effect. This allows
           us to create distributed queues and distributed topics.  <emphasis>Message redistribution
           configuration</emphasis> is another subject that we will insist on.
        </para>

    </section>
</chapter>
