<html>
  <head>
    <title>JBoss Messaging JMS Automatic (Transparent) Failover Example</title>
    <link rel="stylesheet" type="text/css" href="../common/common.css">
  </head>
  <body>
     <h1>JBoss Messaging JMS Automatic (Transparent) Failover (HA) Example</h1>
     <br>
     <p>This example demonstrates two servers coupled as a live-backup pair for high availability (HA), and a client
     connection transparently failing over from live to backup when the live server is crashed.</p>
     <p>JBoss Messaging implements seamless, transparent failover of client connections between live and backup servers.
     This is implemented by the replication of state between live and backup nodes. When replication is configured and a
     live node crashes, the client connections can carry on as if <i>nothing happened</i> and carry on sending and
     consuming messages.</p>
     <p><b>With JBoss Messaging there is no need to code any special client side failover logic in order to benefit from
     failover and HA. There is no need to refactor your messaging applications to work in an HA environment.</b></p>
     <p>JBoss Messaging also supports manual failover which is covered in a separate example.</p> 
     <p>For more information on JBoss Messaging failover and HA, and clustering in general, please see the clustering
     section of the user manual.</p>      
     <h2>Example step-by-step</h2>
     <p><i>To run the example, simply type <code>ant</code> from this directory</i></p>
     <p>In this example, the live server is server 1, and the backup server is server 0</p>
     <p>The connection will initially be created to server1, server 1 will crash, and the client will carry on
     seamlessly on server 0, the backup server.</p>
     <br>
     <ol>
        <li> Get an initial context for looking up JNDI from server 1.</li>
        <pre>
           <code>initialContext = getContext(1);</code>
        </pre>

        <li>Look-up the JMS Queue object from JNDI on server 1.</li>
        <pre>
           <code>Queue queue = (Queue)initialContext.lookup("/queue/exampleQueue");</code>
        </pre>

        <li>Look-up a JMS Connection Factory object from JNDI on server 1</li>
        <pre>
           <code>ConnectionFactory connectionFactory = (ConnectionFactory)initialContext.lookup("/ConnectionFactory");</code>
        </pre>

        <li>We create a JMS Connection</li>
        <pre>
          <code>connection = connectionFactory.createConnection();</code>
        </pre>
        
        <li>We create a JMS Session</li>
        <pre>
           <code>Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</code>
        </pre>
        
        <li>We start the connection to ensure delivery occurs on them</li>
        <pre>
           <code>
   connection.start();
           </code>
        </pre>

        <li>We create a JMS MessageConsumer</li>
        <pre>
           <code>
   MessageConsumer consumer = session.createConsumer(queue);
           </code>
        </pre>

        <li>We create a JMS MessageProducer</li>
        <pre>
           <code>
   MessageProducer producer = session.createProducer(queue);</code>
        </pre>

        <li>We send some messages to server 1, the live server. As we do operations on the live server they are
        transparently replicated to server 0 the backup server, behind the scenes.</li>
        <pre>
           <code>
	      final int numMessages = 10;

         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message = session.createTextMessage("This is text message " + i);

            producer.send(message);

            System.out.println("Sent message: " + message.getText());
         }
           </code>
        </pre>
        
        <li>We now cause server 1, the live server, to crash, and wait a little while to make sure
            it has really crashed. When server 1 crashes, the client automatically detects the failure and automatically
            fails over from server 1 to server 0. (In your real program you wouldn't need to sleep).
        </li>
       
        <pre>
           <code>
	      killServer(1); // This causes the live server to crash
         
         Thread.sleep(2000); // Just wait a little while to make sure the live server has really crashed.
           </code>
        </pre> 
        
        <li>We consume the messages sent before the crash of the live server. We are now transparently
            reconnected to server 0 - the backup server. Note that all this reconnection has been done
            without the client being aware it has been reconnected!</li>
        <pre>
           <code>
         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message0 = (TextMessage)consumer.receive(5000);

            System.out.println("Got message: " + message0.getText());
         }
           </code>
        </pre>
        
        <li>We now send some more messages.</li>
        <pre>
           <code>
         for (int i = numMessages; i < numMessages * 2; i++)
         {
            TextMessage message = session.createTextMessage("This is text message " + i);

            producer.send(message);

            System.out.println("Sent message: " + message.getText());
         }
           </code>
        </pre>
        
        <li>And consume them.</li>
        <pre>
           <code>
         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message0 = (TextMessage)consumer.receive(5000);

            System.out.println("Got message: " + message0.getText());
         }
           </code>
        </pre>

        <li>And finally (no pun intended), <b>always</b> remember to close your resources after use, in a <code>finally</code> block. Closing a JMS connection will automatically close all of its sessions, consumers, producer and browser objects</li>

        <pre>
           <code>
	finally
	{
	   if (connection != null)
      {
         connection.close();
      }

      if (initialContext != null)
      {
         initialContext.close();
      }
	}
           </code>
        </pre>

     </ol>
  </body>
</html>