<html>
  <head>
    <title>JBoss Messaging Paging Example</title>
    <link rel="stylesheet" type="text/css" href="../../common/common.css">
  </head>
  <body>
     <h1>Paging Example</h1>
     <br>
     <p>This example shows how JBoss Messaging would avoid running out of resources by paging messages.</p>
     <p>A maxSize could be specified per Destination on the destinations settings, or a globalMaxSize could also be set on the maing config file.</a>
     <p>When the buffered messages are consuming too much memory, JBossMessaging starts writing messages on the file-system, and as the memory is released by message acknowledgement or transaction commits those messages are recovered from disk and placed in memory</p>
     <p>Acknowledgement plays an important factor on paging as messages will stay on the file system until the memory is released</p> 
       
     <p>A Queue is used to send messages point to point, from a producer to a consumer. The queue guarantees message ordering between these 2 points.</p>
     <br>
     <h2>Example step-by-step</h2>
     <p><i>To run the example, simply type <code>ant</code> from this directory</i></p>
     <br>
     <ol>
        <li>First we need to get an initial context so we can look-up the JMS connection factory and destination objects from JNDI. This initial context will get it's properties from the <code>client-jndi.properties</code> file in the directory <code>../common/config</code></li>
        <pre>
           <code>InitialContext initialContext = getContext();</code>
        </pre>

        <li>We look-up the JMS connection factory object from JNDI</li>
        <pre>
           <code>ConnectionFactory cf = (ConnectionFactory) initialContext.lookup("/ConnectionFactory");</code>
        </pre>

        <li>We look-up the JMS queue object from JNDI. pagingQueue is configured to hold a very limited number of bytes in memory</li>
        <pre>
           <code>Queue pageQueue = (Queue) initialContext.lookup("/queue/pagingQueue");</code>
        </pre>

        <li>We look-up the JMS queue object from JNDI.</li>
        <pre>
           <code>Queue queue = (Queue) initialContext.lookup("/queue/exampleQueue");</code>
        </pre>

        <li>We create a JMS connection</li>
        <pre>
           <code>connection = cf.createConnection();</code>
        </pre>

        <li>We create a JMS session. The session is created as non transacted. We will use client acknowledgement on this example.</li>
        <pre>
           <code>Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);</code>
        </pre>


         <li>Create a JMS Message Producer for pageQueueAddress</li>
         <pre><code>
         MessageProducer pageMessageProducer = session.createProducer(pageQueue);
         </pre></code>
         
         <li>We don't need persistent messages in order to use paging. (This step is optional)</li>
         <pre><code>
         pageMessageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
         </pre></code>
         
         <li>Create a Binary Bytes Message with 10K arbitrary bytes</li>
         <pre><code>
         BytesMessage message = session.createBytesMessage();
         message.writeBytes(new byte[10 * 1024]);
         </pre></code>
         

         <li>Send only 20 messages to the Queue. This will be already enough for pagingQueue. Look at ./paging/config/jbm-queues.xml for the config.</li>
         <pre><code>
         for (int i = 0; i < 20; i++)
         {
            pageMessageProducer.send(message);
         }         
         </pre></code>
         
         <li>Create a JMS Message Producer</li>
         <pre><code>
         MessageProducer messageProducer = session.createProducer(queue);
         </pre></code>
         
         <li>We don't need persistent messages in order to use paging. (This step is optional)</li>
         <pre><code>
         messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
         </pre></code>

         <li>Send the message for about 30K, which should be over the memory limit imposed by the server</li>
         <pre><code>
         for (int i = 0; i < 30000; i++)
         {
            messageProducer.send(message);
         }
         </pre></code>

         <li>if you pause the example here, you will several files under ./build/data/paging</li>
         
         <pre><code>
         // Thread.sleep(30000); // if you want to just our of curiosity, you can sleep here and inspect the created files just for 
         </pre></code>
         
         
         <li>Create a JMS Message Consumer</li>
         <pre><code>
         MessageConsumer messageConsumer = session.createConsumer(queue);
         </pre></code>
         

         <li>Start the JMS Connection. This step will activate the subscribers to receive messages.</li>
         <pre><code>
         connection.start();
         </pre></code>
         
         
         <li>Receive the messages. It's important to ACK for messages as JBM will not read messages from paging until messages are ACKed</li>
         
         <pre><code>
         for (int i = 0; i < 30000; i++)
         {
            message = (BytesMessage)messageConsumer.receive(1000);

            if (i % 1000 == 0)
            {
               System.out.println("Received " + i + " messages");
               
               message.acknowledge();
            }
         }
         </pre></code>
         
         <li>Receive the messages from the Queue names pageQueue. Create the proper consumer for that.</li>
         <pre><code>
         messageConsumer.close();
         messageConsumer = session.createConsumer(pageQueue);

         for (int i = 0; i < 20; i++)
         {
            message = (BytesMessage)messageConsumer.receive(1000);
            
            System.out.println("Received message " + i + " from pageQueue");

            message.acknowledge();
         }
         </pre></code>

        <li>And finally, <b>always</b> remember to close your JMS connections and resources after use, in a <code>finally</code> block. Closing a JMS connection will automatically close all of its sessions, consumers, producer and browser objects</li>

        <pre>
           <code>finally
           {
              if (initialContext != null)
              {
                initialContext.close();
              }
              if (connection != null)
              {
                 connection.close();
              }
           }</code>
        </pre>

     </ol>
  </body>
</html>