<deployment>
   <configuration>
      <!-- The unique id of the server peer - in a cluster each node MUST have a unique value - must be an integer -->
      <server-peer-id>0</server-peer-id>
      <!-- The default JNDI context to use for queues when they are deployed without specifying one -->
      <default-queue-jndi-context>/queue</default-queue-jndi-context>
      <!-- The default JNDI context to use for topics when they are deployed without specifying one -->
      <default-topic-jndi-context>/topic</default-topic-jndi-context>
      <!-- The JAAS security domain to use for JBoss Messaging -->
      <security-domain>java:/jaas/messaging</security-domain>
      <!-- The default security configuration to apply to destinations - this can be overridden on a per destination basis -->
      <default-security-config>
         <role name="guest" read="true" write="true" create="true"/>
      </default-security-config>
      <!-- The default Dead Letter Queue (DLQ) to use for destinations. This can be overridden on a per destinatin basis -->
      <defaul-dlq>DLQ</defaul-dlq>
      <!-- The default maximum number of times to attempt delivery of a message before sending to the DLQ (if configured).
This can be overridden on a per destinatin basis -->
      <default-max-delivery-attempts>10</default-max-delivery-attempts>
      <!-- The default Expiry Queue to use for destinations. This can be overridden on a per destinatin basis -->
      <default-expiry-queue>ExpiryQueue</default-expiry-queue>
      <!-- The default redelivery delay to impose. This can be overridden on a per destination basis -->
      <default-redelivery-delay>0</default-redelivery-delay>
      <!-- The periodicity of the message counter manager enquiring on queues for statistics -->
      <message-counter-sample-period>5000</message-counter-sample-period>
      <!-- The maximum amount of time for a client to wait for failover to start on the server side after
  it has detected failure -->
      <failover-start-timeout>60000</failover-start-timeout>
      <!-- The maximum amount of time for a client to wait for failover to complete on the server side after
  it has detected failure -->
      <failover-complete-timeout>300000</failover-complete-timeout>
      <!-- The maximum number of days results to maintain in the message counter history -->
      <default-message-counter-history-day-limit>-1</default-message-counter-history-day-limit>
      <!-- The name of the connection factory to use for creating connections between nodes to pull messages -->
      <cluster-pull-connection-factory-name>jboss.messaging.connectionfactory:service=ClusterPullConnectionFactory
      </cluster-pull-connection-factory-name>

      <!-- Use XA when pulling persistent messages from a remote node to this one. -->
      <use-xa-for-message-pull>true</use-xa-for-message-pull>
      <!-- When redistributing messages in the cluster. Do we need to preserve the order of messages received
by a particular consumer from a particular producer? -->
      <default-preserve-ordering>false</default-preserve-ordering>

      <!-- Max. time to hold previously delivered messages back waiting for clients to reconnect after failover -->
      <recover-deliveries-timeout>300000</recover-deliveries-timeout>


      <!-- The password used by the message sucker connections to create connections.
           THIS SHOULD ALWAYS BE CHANGED AT INSTALL TIME TO SECURE SYSTEM
      <suckerPassword></suckerPassword>
      -->
      <strict-tck>false</strict-tck>
      <post-office-name>JMS post office</post-office-name>

      <clustered>false</clustered>

      <!-- All the remaining properties only have to be specified if the post office is clustered.
You can safely comment them out if your post office is non clustered -->

      <!-- The JGroups group name that the post office will use -->

      <!--<group-name>MessagingPostOffice</group-name>-->

      <!-- Max time to wait for state to arrive when the post office joins the cluster -->

      <!--<state-timeout>5000</state-timeout>-->

      <!-- Max time to wait for a synchronous call to node members using the MessageDispatcher -->

      <!-- <cast-timeout>50000</cast-timeout>

      <control-channel-name>udp-sync</control-channel-name>
      <data-channel-name>udp</data-channel-name>
      <channel-partition-name>${jboss.partition.name:DefaultPartition}-JMS</channel-partition-name>-->

      <remoting-bind-address>5400</remoting-bind-address>

   </configuration>

   <factories>

      <!-- The default connection factory does not support automatic failover or load balancing-
           this is so we can maintain compatiblity with applications written for JBoss MQ which use this
           connection factory.
      -->
      <factory name="ConnectionFactory">
         <jndi-bindings>
            <binding>/ConnectionFactory</binding>
            <binding>/XAConnectionFactory</binding>
            <binding>java:/ConnectionFactory</binding>
            <binding>java:/XAConnectionFactory</binding>
         </jndi-bindings>
      </factory>

      <factory name="ClusteredConnectionFactory">
         <jndi-bindings>
            <binding>/ClusteredConnectionFactory</binding>
            <binding>/ClusteredXAConnectionFactory</binding>
            <binding>java:/ClusteredConnectionFactory</binding>
            <binding>java:/ClusteredXAConnectionFactory</binding>
         </jndi-bindings>
         <supports-failover>true</supports-failover>
         <supports-load-balancing>true</supports-load-balancing>
      </factory>

      <factory name="jboss.messaging.connectionfactory:service=ClusterPullConnectionFactory">
         <supports-failover>true</supports-failover>
         <supports-load-balancing>true</supports-load-balancing>
      </factory>
      <!-- An example connection factory with all attributes shown  -->

      <factory name="jboss.messaging.connectionfactory:service=MyExampleConnectionFactory">
         <!-- You can specify the default Client ID to use for connections created using this factory -->
         <client-id>MyClientID</client-id>
         <!-- PrefetchSize determines the approximate maximum number of messages the client consumer will buffer locally -->
         <prefetch-size>150</prefetch-size>
         <!-- Paging params to be used for temporary queues -->
         <default-temp-queue-full-size>200000</default-temp-queue-full-size>
         <default-temp-queue-page-size>2000</default-temp-queue-page-size>
         <default-temp-queue-down-cache-size>2000</default-temp-queue-down-cache-size>
         <!-- The batch size to use when using the DUPS_OK_ACKNOWLEDGE acknowledgement mode -->
         <dups-ok-batch-size>5000</dups-ok-batch-size>
         <!-- Does this connection factory support automatic failover? -->
         <supports-failover>false</supports-failover>
         <!-- Does this connection factory support automatic client side load balancing? -->
         <supports-load-balancing>false</supports-load-balancing>
         <!-- The class name of the factory used to create the load balancing policy to use on the client side -->
         <load-balancing-factory>org.jboss.jms.client.plugin.RoundRobinLoadBalancingFactory</load-balancing-factory>
         <!-- Whether we should be strict TCK compliant, i.e. how we deal with foreign messages, defaults to false-->
         <strict-tck>true</strict-tck>
         <!-- Disable JBoss Remoting Connector sanity checks - There is rarely a good reason to set this to true -->
         <disable-remoting-checks>false</disable-remoting-checks>
         <!-- The connection factory will be bound in the following places in JNDI -->
         <jndi-bindings>
            <binding>/acme/MyExampleConnectionFactory</binding>
            <binding>/acme/MyExampleConnectionFactoryDupe</binding>
            <binding>java:/xyz/CF1</binding>
            <binding>java:/connectionfactories/acme/connection_factory</binding>
         </jndi-bindings>
      </factory>

   </factories>

   <destinations>
      <!--
         The Default Dead Letter Queue. This destination is a dependency of an EJB MDB container.
      -->
      <queue name="DLQ"/>
      <!--
         The Default Expiry Queue.
      -->
      <queue name="ExpiryQueue"/>
      <!--
           Example destinations.
      -->
      <topic name="testTopic">
         <security>
            <role name="guest" read="true" write="true"/>
            <role name="publisher" read="true" write="true" create="false"/>
            <role name="durpublisher" read="true" write="true" create="true"/>
         </security>
      </topic>

      <topic name="securedTopic">
         <security>
            <role name="publisher" read="true" write="true" create="false"/>
         </security>
      </topic>

      <topic name="testDurableTopic">
         <security>
            <role name="guest" read="true" write="true"/>
            <role name="publisher" read="true" write="true" create="false"/>
            <role name="durpublisher" read="true" write="true" create="true"/>
         </security>
      </topic>

      <queue name="testQueue">
         <security>
            <role name="guest" read="true" write="true"/>
            <role name="publisher" read="true" write="true" create="false"/>
            <role name="noacc" read="false" write="false" create="false"/>
         </security>
      </queue>

      <queue name="A"/>
      <queue name="B"/>
      <queue name="C"/>
      <queue name="D"/>
      <queue name="ex"/>

      <!-- It's possible for indiviual queues and topics to use a specific queue for
  an expiry or DLQ -->

      <queue name="PrivateDLQ"/>
      <queue name="PrivateExpiryQueue"/>
      <queue name="QueueWithOwnDLQAndExpiryQueue">
         <dlq>PrivateDLQ</dlq>
         <expiry-queue>PrivateExpiryQueue</expiry-queue>
      </queue>

      <topic name="TopicWithOwnDLQAndExpiryQueue">
         <dlq>PrivateDLQ</dlq>
         <expiry-queue>PrivateExpiryQueue</expiry-queue>
      </topic>

      <!-- Queues and Topics can also specify their own redelivery delay -->
      <queue name="QueueWithOwnRedeliveryDelay">
         <redelivery-delay>5000</redelivery-delay>
      </queue>

      <topic name="TopicWithOwnRedeliveryDelay">
         <redelivery-delay>5000</redelivery-delay>
      </topic>

      <!--
           Example clustered destinations.
      -->
      <queue name="testDistributedQueue">
         <clustered>true</clustered>
      </queue>

      <topic name="testDistributedTopic">
         <clustered>true</clustered>
      </topic>

   </destinations>

</deployment>