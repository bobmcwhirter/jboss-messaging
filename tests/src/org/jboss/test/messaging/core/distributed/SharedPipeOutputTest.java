/**
 * JBoss, the OpenSource J2EE WebOS
 *
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 */
package org.jboss.test.messaging.core.distributed;

import org.jboss.test.messaging.MessagingTestCase;


/**
 * @author <a href="mailto:ovidiu@jboss.org">Ovidiu Feodorov</a>
 * @version <tt>$Revision$</tt>
 */
public class SharedPipeOutputTest extends MessagingTestCase
{
//
//   private static final Logger log = Logger.getLogger(SharedPipeOutputTest.class);
//
//   // Constants -----------------------------------------------------
//
//   private String props =
//         "UDP(mcast_addr=228.1.2.3;mcast_port=45566;ip_ttl=32):"+
//         "PING(timeout=3050;num_initial_members=6):"+
//         "FD(timeout=3000):"+
//         "VERIFY_SUSPECT(timeout=1500):"+
//         "pbcast.NAKACK(gc_lag=10;retransmit_timeout=600,1200,2400,4800):"+
//         "UNICAST(timeout=600,1200,2400,4800):"+
//         "pbcast.STABLE(desired_avg_gossip=10000):"+
//         "FRAG:"+
//         "pbcast.GMS(join_timeout=5000;join_retry_timeout=2000;shun=true;print_local_addr=true)";
//
//   // Attributes ----------------------------------------------------
//
//   private JChannel inputChannelOne, inputChannelTwo, outputChannel;
//   private RpcDispatcher inputDispatcherOne, inputDispatcherTwo, outputDispatcher;
//   private Address outputAddress;
//
//
   // Constructors --------------------------------------------------

   public SharedPipeOutputTest(String name)
   {
      super(name);
   }
//
//   // Protected -----------------------------------------------------
//
//   // Public --------------------------------------------------------
//
//   protected void setUp() throws Exception
//   {
//      super.setUp();
//
//      inputChannelOne = new JChannel(props);
//      inputDispatcherOne = new RpcDispatcher(inputChannelOne, null, null, null);
//
//      inputChannelTwo = new JChannel(props);
//      inputDispatcherTwo = new RpcDispatcher(inputChannelTwo, null, null, null);
//
//      outputChannel = new JChannel(props);
//      RpcServer rpcServer = new RpcServer();
//      outputDispatcher = new RpcDispatcher(outputChannel, null, null, rpcServer);
//
//      inputChannelOne.connect("testGroup");
//      inputChannelTwo.connect("testGroup");
//      outputChannel.connect("testGroup");
//      outputAddress = outputChannel.getLocalAddress();
//   }
//
//   protected void tearDown() throws Exception
//   {
//      inputChannelOne.close();
//      inputChannelTwo.close();
//      outputChannel.close();
//      super.tearDown();
//   }
//
//
//   public void testTwoInputsSharingAnOutput() throws Exception
//   {
//      assertTrue(inputChannelOne.isConnected());
//      assertTrue(inputChannelTwo.isConnected());
//      assertTrue(outputChannel.isConnected());
//
//      Pipe inputPipeOne = new Pipe(true, inputDispatcherOne, outputAddress, "samePipeID");
//      Pipe inputPipeTwo = new Pipe(true, inputDispatcherTwo, outputAddress, "samePipeID");
//
//
//      ReceiverImpl r = new ReceiverImpl();
//      PipeOutput po = new PipeOutput("samePipeID", r);
//      po.register((RpcServer)outputDispatcher.getServerObject());
//
//      Sender senderOne = new Sender("ONE", inputPipeOne);
//      Sender senderTwo = new Sender("TWO", inputPipeTwo);
//      new Thread(senderOne, "Sender Thread ONE").start();
//      new Thread(senderTwo, "Sender Thread TWO").start();
//
//      long sleep = 5000;
//      log.info("The main thead is sleeping for " + (sleep / 1000) + " seconds ...");
//      Thread.sleep(sleep);
//      log.info("The main thread finishing up ...");
//
//      List messages =  r.messages();
//      assertEquals(2, messages.size());
//      assertTrue(messages.contains(new MessageSupport("GENERATED BY ONE")));
//      assertTrue(messages.contains(new MessageSupport("GENERATED BY TWO")));
//      assertTrue(senderOne.getHandleResult());
//      assertTrue(senderTwo.getHandleResult());
//
//   }
//
//
//   private class Sender implements Runnable
//   {
//      private Pipe pi;
//      private String name;
//      private boolean handleResult;
//
//      public Sender(String name, Pipe pi)
//      {
//         this.pi = pi;
//         this.name = name;
//      }
//
//      public void run()
//      {
//         Routable m = new MessageSupport("GENERATED BY " + name);
//         handleResult = pi.handle(m);
//         log.info("Sender " + name + " pi.handle() got " + handleResult);
//      }
//
//      public boolean getHandleResult()
//      {
//         return handleResult;
//      }
//   }
//
//   private class ReceiverImpl implements Receiver
//   {
//      private List messages = new ArrayList();
//
//      public Serializable getReceiverID()
//      {
//         return "GenericReceiver";
//      }
//
//      public boolean handle(Routable m)
//      {
//         synchronized(messages)
//         {
//            messages.add(m);
//         }
//         long sleep = 1000;
//         log.info("Receiver is handling message " + m +
//                  " and sleeps for " + (sleep / 1000) + " seconds ... ");
//         try
//         {
//            Thread.sleep(sleep);
//         }
//         catch(Exception e)
//         {
//         }
//         log.info("Receiver wakes up ...");
//         return true;
//      }
//
//      public List messages()
//      {
//         return messages;
//      }
//   }
//

   public void testNoop()
   {
   }
   

}
